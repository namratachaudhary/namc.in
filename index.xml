<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>__namc</title><link>/</link><description>Recent content on __namc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Blog by Namrata Chaudhary</copyright><lastBuildDate>Tue, 16 Apr 2019 14:02:18 -0700</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Retries, Timeouts and Backoff</title><link>/posts/retries-timeouts-backoff/</link><pubDate>Tue, 16 Apr 2019 14:02:18 -0700</pubDate><guid>/posts/retries-timeouts-backoff/</guid><description>Distributed systems are hard. While we learn a lot about making highly available systems, we often overlook resiliency in system design.
Sure we have heard about fault-tolerant, but what is &amp;ldquo;resilience&amp;rdquo; now? Personally, I like to define it a system&amp;rsquo;s ability to handle and eventually recover from unexpected conditions. There are several ways to go about making your systems resilient to failure, but in this post, we will focus on following</description></item><item><title>SSH Tunneling - Local, Remote &amp; Dynamic</title><link>/posts/ssh-port-forwarding/</link><pubDate>Tue, 26 Jun 2018 14:02:18 -0700</pubDate><guid>/posts/ssh-port-forwarding/</guid><description>Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.
We&amp;rsquo;re going to look at the three types of port forwarding - local, remote &amp;amp; dynamic.</description></item><item><title>Haskell Lens - Part 1</title><link>/posts/lenses-part-1/</link><pubDate>Mon, 26 Mar 2018 13:00:58 +0530</pubDate><guid>/posts/lenses-part-1/</guid><description>Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead.</description></item><item><title>What is Currying</title><link>/posts/currying/</link><pubDate>Thu, 22 Feb 2018 12:07:52 +0530</pubDate><guid>/posts/currying/</guid><description>Inspiration This post is written after I saw this tweet
Every functional programming tutorial:
&amp;gt; OK, we&amp;#39;re going to talk about currying. Currying is when you break down a function tha-
*scrolls down*
&amp;gt; const Y = f =&amp;gt; (g =&amp;gt; g(g))(g =&amp;gt; f(x =&amp;gt; g(g)(x))) pic.twitter.com/EPHH9SG5ay
&amp;mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage.</description></item><item><title>Foldable and Traversable in Haskell</title><link>/posts/foldables-traversals/</link><pubDate>Wed, 24 Jan 2018 12:07:52 +0530</pubDate><guid>/posts/foldables-traversals/</guid><description>Foldable Foldable represents data structure type class that
provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
Get the product of a list Get the max path value in a tree In short, fold can be understood as function to reduce a large structure into a single result.</description></item><item><title>Haskell's Applicative Functors</title><link>/posts/applicative-functors/</link><pubDate>Fri, 12 Jan 2018 18:20:12 +0530</pubDate><guid>/posts/applicative-functors/</guid><description>Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc.</description></item><item><title>lazy-seq - Lazy Sequences in Clojure</title><link>/posts/lazy-seq/</link><pubDate>Wed, 10 Jan 2018 01:00:46 +0530</pubDate><guid>/posts/lazy-seq/</guid><description>Basic idea Evaluation of an expression is delayed until the value is needed.
There are two ways to achieve the above :
use lambda functions at runtime
use macros/special forms at compile time
With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms.</description></item><item><title>Structured Clojure: Protocols</title><link>/posts/protocols/</link><pubDate>Thu, 04 Jan 2018 10:20:20 +0530</pubDate><guid>/posts/protocols/</guid><description>Protocols in clojure are a way to define functions that operate in different ways on different types. As someone mentioned, Clojure protocols help in solving the expression problem.
Expression Problem Your program is a combination of a datatype and operations over it.
Expression problem calls for an implementation of the program such that —
new functionalities and data-structures can be added that play well with existing functionality
the above is done whilst maintaining type safety; i.</description></item><item><title>Clojure - Atoms</title><link>/posts/atoms/</link><pubDate>Tue, 26 Dec 2017 12:39:46 +0530</pubDate><guid>/posts/atoms/</guid><description>In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.</description></item></channel></rss>