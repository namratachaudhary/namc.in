<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Haskell on __namc</title><link>/tags/haskell/</link><description>Recent content in Haskell on __namc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by [panr](https://twitter.com/panr)</copyright><lastBuildDate>Mon, 26 Mar 2018 13:00:58 +0530</lastBuildDate><atom:link href="/tags/haskell/index.xml" rel="self" type="application/rss+xml"/><item><title>Haskell Lens - Part 1</title><link>/posts/lenses-part-1/</link><pubDate>Mon, 26 Mar 2018 13:00:58 +0530</pubDate><guid>/posts/lenses-part-1/</guid><description>Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead.</description></item><item><title>What is Currying</title><link>/posts/currying/</link><pubDate>Thu, 22 Feb 2018 12:07:52 +0530</pubDate><guid>/posts/currying/</guid><description>Inspiration This post is written after I saw this tweet
Every functional programming tutorial:
&amp;gt; OK, we&amp;#39;re going to talk about currying. Currying is when you break down a function tha-
*scrolls down*
&amp;gt; const Y = f =&amp;gt; (g =&amp;gt; g(g))(g =&amp;gt; f(x =&amp;gt; g(g)(x))) pic.twitter.com/EPHH9SG5ay
&amp;mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage.</description></item><item><title>Foldable and Traversable in Haskell</title><link>/posts/foldables-traversals/</link><pubDate>Wed, 24 Jan 2018 12:07:52 +0530</pubDate><guid>/posts/foldables-traversals/</guid><description>Foldable Foldable represents data structure type class that
provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
Get the product of a list Get the max path value in a tree In short, fold can be understood as function to reduce a large structure into a single result.</description></item><item><title>Haskell's Applicative Functors</title><link>/posts/applicative-functors/</link><pubDate>Fri, 12 Jan 2018 18:20:12 +0530</pubDate><guid>/posts/applicative-functors/</guid><description>Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc.</description></item></channel></rss>