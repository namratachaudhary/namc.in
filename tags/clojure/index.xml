<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clojure on __namc</title><link>/tags/clojure/</link><description>Recent content in Clojure on __namc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by [panr](https://twitter.com/panr)</copyright><lastBuildDate>Wed, 10 Jan 2018 01:00:46 +0530</lastBuildDate><atom:link href="/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>lazy-seq - Lazy Sequences in Clojure</title><link>/posts/lazy-seq/</link><pubDate>Wed, 10 Jan 2018 01:00:46 +0530</pubDate><guid>/posts/lazy-seq/</guid><description>Basic idea Evaluation of an expression is delayed until the value is needed.
There are two ways to achieve the above :
use lambda functions at runtime
use macros/special forms at compile time
With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms.</description></item><item><title>Structured Clojure: Protocols</title><link>/posts/protocols/</link><pubDate>Thu, 04 Jan 2018 10:20:20 +0530</pubDate><guid>/posts/protocols/</guid><description>Protocols in clojure are a way to define functions that operate in different ways on different types. As someone mentioned, Clojure protocols help in solving the expression problem.
Expression Problem Your program is a combination of a datatype and operations over it.
Expression problem calls for an implementation of the program such that —
new functionalities and data-structures can be added that play well with existing functionality
the above is done whilst maintaining type safety; i.</description></item><item><title>Clojure - Atoms</title><link>/posts/atoms/</link><pubDate>Tue, 26 Dec 2017 12:39:46 +0530</pubDate><guid>/posts/atoms/</guid><description>In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.</description></item></channel></rss>