<!doctype html><html lang=en><head><title>Observability Cloud Infrastructure - Using the right tools :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Creating a very basic and bare-minimum observable infrastructure Considering that the system engineer is somewhat well-versed with cloud-friendly observability tools, let’s look at some tools that can help lay-down a sound foundation for system observability
Prometheus to scrape data from K8S resources
A good practice would be to use observable containers (application containers that push metrics to an endpoint). A lot can be automated with CR auto discovery from the Prometheus Operator."><meta name=keywords content="cloud,kubernetes,monitoring,logging"><meta name=robots content="noodp"><link rel=canonical href=/posts/cloud-observability-ii/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Observability Cloud Infrastructure - Using the right tools :: __namc —"><meta name=twitter:description content="Creating a very basic and bare-minimum observable infrastructure Considering that the system engineer is somewhat well-versed with cloud-friendly observability tools, let’s look at some tools that can help lay-down a sound foundation for system observability
Prometheus to scrape data from K8S resources
A good practice would be to use observable containers (application containers that push metrics to an endpoint). A lot can be automated with CR auto discovery from the Prometheus Operator."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Observability Cloud Infrastructure - Using the right tools :: __namc —"><meta property="og:description" content="Creating a very basic and bare-minimum observable infrastructure Considering that the system engineer is somewhat well-versed with cloud-friendly observability tools, let’s look at some tools that can help lay-down a sound foundation for system observability
Prometheus to scrape data from K8S resources
A good practice would be to use observable containers (application containers that push metrics to an endpoint). A lot can be automated with CR auto discovery from the Prometheus Operator."><meta property="og:url" content="/posts/cloud-observability-ii/"><meta property="og:site_name" content="Observability Cloud Infrastructure - Using the right tools"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-05-12 06:25:12 +0200 +0200"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/cloud-observability-ii/>Observability Cloud Infrastructure - Using the right tools</a></h1><div class=post-meta><span class=post-date>May 12, 2020</span></div><span class=post-tags>#<a href=/tags/devops/>Devops</a>&nbsp;</span><div class=post-content><div><h2 id=creating-a-very-basic-and-bare-minimum-observable-infrastructure>Creating a very basic and bare-minimum observable infrastructure<a href=#creating-a-very-basic-and-bare-minimum-observable-infrastructure class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Considering that the system engineer is somewhat well-versed with cloud-friendly observability tools, let’s look at some tools that can help lay-down a sound foundation for system observability</p><h3 id=prometheushttpsprometheusio><a href=https://prometheus.io/>Prometheus</a><a href=#prometheushttpsprometheusio class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>to scrape data from K8S resources</strong></p><p>A good practice would be to use observable containers (application containers that push metrics to an endpoint). A lot can be automated with CR auto discovery from the Prometheus Operator. If you are using helm charts, this is already enabled by default. Prometheus provides an interface for querying metrics (PromQL)</p><p>Deploy using Prometheus operator :</p><ul><li>simplifies configuration by using CRDs to define the jobs and rules.</li><li>far easier to maintain configurations in a bunch of small files, rather than a monolithic config with multiple scrapes.</li><li>adds common components (node-exporter, kube-state-metrics, grafana, etc).</li></ul><h3 id=victoriametricshttpsvictoriametricscom--thanoshttpsthanosiogetting-startedmd><a href=https://victoriametrics.com/>VictoriaMetrics</a> / <a href=https://thanos.io/getting-started.md/>Thanos</a><a href=#victoriametricshttpsvictoriametricscom--thanoshttpsthanosiogetting-startedmd class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>for storing all historical metrics data</strong></p><p>Prometheus stores data on disk, therefore you can assume that your metric data will be short lived. Victoria Metrics and Thanos is built on top of Prometheus and stores all your historical metric data for unlimited time Compatible with PromQL therefore, it can be used to generate visualizations on Grafana using the same queries as that for Prometheus. It exposes a &ldquo;master Prometheus&rdquo; to scrape data from all Prometheus instances.</p><p>Some tangential but necessary advantages include - high availability, querying across instances, long-term block storage, query-level downsampling</p><h3 id=grafana>Grafana<a href=#grafana class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>to visualize metrics data and logs</strong></p><p>Grafana lays out the metrics in visual appeasing manner using templates provided (proprietary, OSS). Grafana integrates beautifully with Prometheus and it is compatible with PromQL. You can build custom charts using PromQL and combine multiple metrics across applications.</p><p>Grafana is a state of the art visualization tool in the industry, and open source too. It integrates with plenty of other tools, thereby making it a one-stop shop for all visualization needs.</p><h3 id=lokihttpsgithubcomgrafanaloki><a href=https://github.com/grafana/loki>Loki</a><a href=#lokihttpsgithubcomgrafanaloki class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>for building a logging framework</strong></p><p>This tool is absolutely necessary if you want to process log files. However, it does not index log files [like ElasticSearch] but indexes metadata.</p><p>If you don&rsquo;t need Fulltext indexing, and grepping your logs is sufficient use case, go for <code>loki</code>. It will be fast, reliable, already well integrated in kubernetes and managed easier. It is also compatible with Grafana, hence no need for additional visualization tools.</p><h3 id=fluentdhttpswwwfluentdorg><a href=https://www.fluentd.org/>Fluentd</a><a href=#fluentdhttpswwwfluentdorg class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>for collecting all your logs</strong></p><p>A log collector to gather all kinds of logs and translate them to JSON. It enables other systems to seamlessly work with the data.</p><p>There are multiple options to setup Fluentd with your system -</p><ul><li>setup a logfile watcher as input, which sends the log messages over to a logfile writer on another machine, all within 5..10 minutes on 2 VMs.</li><li>directly write messages (JSON or MessagePack) to a TCP socket (MessagePack-formatted messages to TCP socket is basically the lowest level you get).</li></ul><p>It&rsquo;s basically just input plugins connected to output plugins, and you build a message distribution network from that.</p><p>Fluentd is automatically installed by Google on their GKE instances.</p><h3 id=kubecosthttpskubecostcom><a href=https://kubecost.com/>KubeCost</a><a href=#kubecosthttpskubecostcom class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>to determine how much your kubernetes resources are costing you</strong></p><p>KubeCost provides cost allocation models for kubernetes workloads across various cloud providers. In a shared cluster, it helps in linking the costs to the resources and link that to users/teams. This also helps in being able to estimate, analyse, and create accurate reporting on costs</p><p>This is truly essential for firms that operate on a budget and need more visibility of resource allocation and optimization within the organisation</p><h3 id=final-words>Final words<a href=#final-words class=hanchor arialabel=Anchor>&#8983;</a></h3><p>It&rsquo;s a rich ecosystem with flexible and powerful parts. As a warning, there are strong opinions in how to configure certain things. You may require supplemental work depending on your org&rsquo;s requirements and what you want to accomplish.</p><p>So head over to the CNCF landscape and create the stack you like.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/cloud-observability/><span class=button__text>Understanding Observability (and the family) in Cloud Infrastructure</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>