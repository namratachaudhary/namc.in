<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="__namc"><meta property="og:url" content="/posts/higher-rank-higher-kinded-types/"><link rel=canonical href=/posts/higher-rank-higher-kinded-types/><link rel=alternate type=application/atom+xml href=/index.xml title="Namc's blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Haskell : Higher-Rank and Higher-Kinded Types","headline":"Haskell : Higher-Rank and Higher-Kinded Types","description":"Hi! We\x26rsquo;re gonna look at higher-rank and higher-kinded types, specifically in Haskell but I will try to cover the concept as generically as possible.\nTwo types of \x26ldquo;Polymorphism\x26rdquo; in Haskell  Parametric Polymorphism Ad-hoc Polymorphism (also known as typeclass)  A function is parametrically polymorphic if it behaves uniformly for all types, in at least one of its type parameters\nCouple of examples could be -\na. Simple swap function","inLanguage":"en-US","author":"__namc","creator":"__namc","publisher":"__namc","accountablePerson":"__namc","copyrightHolder":"__namc","copyrightYear":"2020","datePublished":"2020-06-15 12:20:12 \x2b0530 \x2b0530","dateModified":"2020-06-15 12:20:12 \x2b0530 \x2b0530","url":"\/posts\/higher-rank-higher-kinded-types\/","keywords":["Haskell"]}</script><title>Haskell : Higher-Rank and Higher-Kinded Types - Namc's blog</title><meta property="og:title" content="Haskell : Higher-Rank and Higher-Kinded Types - Namc's blog"><meta property="og:type" content="article"><meta property="og:description" content="Hi! We&rsquo;re gonna look at higher-rank and higher-kinded types, specifically in Haskell but I will try to cover the concept as generically as possible.
Two types of &ldquo;Polymorphism&rdquo; in Haskell  Parametric Polymorphism Ad-hoc Polymorphism (also known as typeclass)  A function is parametrically polymorphic if it behaves uniformly for all types, in at least one of its type parameters
Couple of examples could be -
a. Simple swap function"><meta name=description content="Hi! We&rsquo;re gonna look at higher-rank and higher-kinded types, specifically in Haskell but I will try to cover the concept as generically as possible.
Two types of &ldquo;Polymorphism&rdquo; in Haskell  Parametric Polymorphism Ad-hoc Polymorphism (also known as typeclass)  A function is parametrically polymorphic if it behaves uniformly for all types, in at least one of its type parameters
Couple of examples could be -
a. Simple swap function"><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Namc's blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Haskell : Higher-Rank and Higher-Kinded Types</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2020-06-15 12:20:12 +0530">15 Jun 2020</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://namc.in/>@__namc</a></div></div></div></header><div class="post-content markdown-body"><p>Hi! We&rsquo;re gonna look at higher-rank and higher-kinded types, specifically in Haskell but I will try to cover the concept as generically as possible.</p><h2 id=two-types-of-polymorphism-in-haskell>Two types of &ldquo;Polymorphism&rdquo; in Haskell</h2><ul><li>Parametric Polymorphism</li><li>Ad-hoc Polymorphism (also known as typeclass)</li></ul><p><strong>A function is parametrically polymorphic if it behaves uniformly for all types, in at least one of its type parameters</strong></p><p>Couple of examples could be -</p><p>a. Simple swap function</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>swap</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=p>)</span>
<span class=nf>swap</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</code></pre></div><p>b. Not-so-simple len function</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- Maps each element to a 1, then sums up all the elements</span>
<span class=nf>len</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=kt>Integer</span>
<span class=nf>len</span> <span class=ow>=</span> <span class=n>sum</span> <span class=o>.</span> <span class=n>map</span> <span class=p>(</span><span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>1</span><span class=p>)</span>
</code></pre></div><p>The idea is, you want these functions to work for all values of <code>a</code> or <code>b</code>. The function <code>swap</code> will swap elements regardless of their types, and function <code>len</code> returns the length of a list no matter of what is in that list.</p><p>This is also what we call <em>generics</em> in Java or <em>templates</em> in C++ - but it was first introduced in Ocaml, Standard ML and the kinds.</p><p>Now what if we need a way to write an unique a function which accepts any type for which a computation/operation is possible and we need to provide a specific implementation for each case. This is <strong>ad-hoc polymorphism</strong> and we use <em>typelasses</em> in Haskell to implement this.</p><p>Everyone loves demonstrating this with <code>area</code> function example so let&rsquo;s do that. Also, the <code>Show</code>, <code>Ord</code>, <code>Eq</code> typeclasses are inherited by free from parametric polymorphism.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=cm>{-</span><span class=cm># LANGUAGE FlexibleInstances #</span><span class=cm>-}</span>
<span class=cm>{-</span><span class=cm># LANGUAGE TypeSynonymInstances #</span><span class=cm>-}</span>
<span class=cm>{-</span><span class=cm># LANGUAGE TypeFamilies #</span><span class=cm>-}</span>

<span class=kr>class</span> <span class=kt>Area</span> <span class=n>t</span> <span class=kr>where</span>
  <span class=n>area</span> <span class=ow>::</span> <span class=n>t</span> <span class=ow>-&gt;</span> <span class=kt>Float</span>

<span class=kr>instance</span> <span class=kt>Area</span> <span class=kt>Square</span> <span class=kr>where</span>
  <span class=n>area</span> <span class=p>(</span><span class=kt>Square</span> <span class=n>s</span><span class=p>)</span> <span class=ow>=</span> <span class=n>s</span> <span class=o>*</span> <span class=n>s</span>

<span class=kr>instance</span> <span class=kt>Area</span> <span class=kt>Rectangle</span> <span class=kr>where</span>
  <span class=n>area</span> <span class=p>(</span><span class=kt>Rectangle</span> <span class=n>a</span> <span class=n>b</span><span class=p>)</span> <span class=ow>=</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span>
</code></pre></div><p>Conclusively - If your function does not care about input type, or need any context about them, then parametric polymorphism is the way to go, else use ad-hoc polymorphism and add implementation for each type.</p><p>For this part, we only need to focus on <strong>PARAMETRIC POLYMORPHISM</strong> Moving on..</p><p><strong>(Not-so) Fun fact time</strong>
Since Haskell&rsquo;s type-system is based on <strong><a href=https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system>Hindley-Milner</a></strong> also commonly known as <em>let-bound polymorphism</em> implies using <code>let</code> or <code>where</code> bound indentifiers are polymorphic, but lambda-bound identifiers are monomorphic. More info here - <a href=https://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/pitfalls.html>Haskell - Type Pitfalls</a></p><h2 id=higher-rank-types>Higher-rank types</h2><p>In most languages, polymorphic functions are first-class values ; by defintion, can be stored in variables and passed to functions. But in Haskell, they are not. Higher rank types , or as they&rsquo;re called <code>RankNTypes</code> in Haskell are used to make polymorphic functions first-class, just like regular (monomorphic) functions.</p><p><a href=https://wiki.haskell.org/Rank-N_types><code>RankNTypes</code></a> does this by introducting <code>forall</code> argument to the function type.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>--- Illegal Foo!</span>
<span class=nf>foo</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Int</span><span class=p>,</span> <span class=kt>Char</span><span class=p>)</span>
<span class=nf>foo</span> <span class=ow>=</span> <span class=p>(</span><span class=nf>\</span><span class=n>f</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>f</span> <span class=mi>1</span><span class=p>,</span> <span class=n>f</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span><span class=p>)</span> <span class=n>id</span>
</code></pre></div><p>The above function <code>foo</code> can be fixed by -</p><ul><li><p>binding <code>f</code> with <code>let</code> or <code>where</code> (using let-bound polymorphism)</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>foo</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Int</span><span class=p>,</span> <span class=kt>Char</span><span class=p>)</span>
<span class=nf>foo</span> <span class=ow>=</span> <span class=kr>let</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>id</span>
     <span class=kr>in</span> <span class=p>(</span><span class=n>f</span> <span class=mi>1</span><span class=p>,</span> <span class=n>f</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span>
</code></pre></div></li><li><p>using <code>RankNTypes</code> extension</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=cm>{-</span><span class=cm># LANGUAGE RankNTypes #</span><span class=cm>-}</span>
<span class=cm>{-</span><span class=cm># LANGUAGE ScopedTypeVariables #</span><span class=cm>-}</span>

<span class=nf>foo</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Int</span><span class=p>,</span> <span class=kt>Char</span><span class=p>)</span>
<span class=nf>foo</span> <span class=ow>=</span> <span class=p>(</span><span class=nf>\</span><span class=p>(</span><span class=n>f</span> <span class=ow>::</span> <span class=n>forall</span> <span class=n>a</span><span class=o>.</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>f</span> <span class=mi>1</span><span class=p>,</span> <span class=n>f</span> <span class=sc>&#39;a&#39;</span><span class=p>)</span><span class=p>)</span> <span class=n>id</span>
</code></pre></div></li></ul><p>To be honest, this does not usually come up in Haskell, or any statically typed language because supporting higher-rank types make type inference undecidable - <a href=https://www.sciencedirect.com/science/article/pii/S0168007298000475>Typability and type checking in System F are equivalent and undecidable</a>. Ryan Scott&rsquo;s blog does a great job at explaining why working with Higher-rank Kinds is a bit tedious, but it is also a great resource for someone wanting to explore this further. <a href=https://ryanglscott.github.io/2019/07/10/the-surprising-rigidness-of-higher-rank-kinds/>The surprising rigidness of higher-rank kinds</a>.</p><h2 id=higher-kinded-types>Higher-kinded types</h2><p>Also known as type of types or <em>type operators</em> .. but is it really?</p><p>Higher-kinded types are really common in Haskell (vs higher-rank types). Commonly known as <code>Functor</code> or <code>Monad</code> - they are popular examples of higher-kinded polymorphism.</p><p>As <a href=http://dev.stephendiehl.com/fun/001_basics.html#higher-kinded-types>Stephen Diehl mentions</a> - kind of an ordinary type is usually written as <code>*</code>, and type constructors (unary type operators) have kind <code>* -> *</code></p><p>To make it simpler to understand -</p><ul><li>The kind <code>*</code> is also known as ground, or 0th order.</li><li>Any kind of the form <code>* -> * -> ... -> *</code> with at least one arrow is first-order.</li><li>A higher-order kind is one that has a &ldquo;nested arrow on the left&rdquo;, e.g., <code>(* -> *) -> *</code>.</li></ul><p>We can look at some commonly used defintions -</p><ul><li><p><strong>Maybe</strong></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kt>Maybe</span> <span class=kt>:</span> <span class=kt>Type</span><span class=ow>-&gt;</span><span class=kt>Type</span>
</code></pre></div><p>Since, we cannot get a type from type constructor, we can get a <code>kind</code> . Therefore,</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>λ</span><span class=o>&gt;</span> <span class=kt>:</span><span class=n>k</span> <span class=kt>Maybe</span>
<span class=kt>Maybe</span> <span class=ow>::</span> <span class=o>*</span> <span class=ow>-&gt;</span> <span class=o>*</span>
</code></pre></div></li><li><p><strong>Shape</strong></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Shape</span> <span class=n>f</span> <span class=ow>=</span> <span class=kt>Shape</span> <span class=p>(</span><span class=n>f</span> <span class=nb>()</span><span class=p>)</span>
<span class=p>[</span><span class=nb>()</span><span class=p>,</span> <span class=nb>()</span><span class=p>,</span> <span class=nb>()</span><span class=p>]</span> <span class=ow>::</span> <span class=kt>Shape</span> <span class=kt>List</span>
</code></pre></div><p>Which you can further divide into <code>Traversables</code> and break it down into further components.</p></li></ul><p>Next, we will look at a basic definition of class <code>Functor</code></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>class</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span>
</code></pre></div><p><code>fmap</code> changes the type parameter of an <code>f</code> from <code>a</code> to <code>b</code> but does not change <code>f</code>.
If we use <code>fmap</code> over a list, we get a list (etc). These are compile-time guarantees (revisited later).</p><p>Two questions here -</p><ul><li>Can&rsquo;t we just use function overloading instead?</li><li>What if we simply convert our types to <code>Seq</code> and do whatever we want with it?</li></ul><p>Well, that&rsquo;s correct. Additionally if you have a type which supports conversion to and from <code>Seq</code> you get <code>map</code> by reusing <code>Seq.map</code>.</p><p>Why do we need a Functor class? First, functor classes allow you to implement fmap for types which do not support conversion to and from <code>Seq</code> like - IO actions, functions, etc. Therefore, making the concept of mapping very sequence-agnostic.</p><p>As we have seen previously the two functor laws -</p><ul><li><code>fmap id xs == xs</code> : mapping with an identity/noop function is the same as doing nothing</li><li><code>fmap f (fmap g xs) = fmap (f . g) xs</code> : any result that you can produce by mapping twice, you can also produce by mapping once</li></ul><p>Which is why, its important for <code>fmap</code> to maintain the static, compile time guarantees of preserving types.</p><p>So if we try to define functor class over IO - we get :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>IO</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=n>action</span> <span class=ow>=</span>
        <span class=kr>do</span> <span class=n>x</span> <span class=ow>&lt;-</span> <span class=n>action</span>
           <span class=n>return</span> <span class=p>(</span><span class=n>f</span> <span class=n>x</span><span class=p>)</span>

<span class=kr>newtype</span> <span class=kt>Function</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=kt>Function</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span>

<span class=kr>instance</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>Function</span> <span class=n>a</span><span class=p>)</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Function</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Function</span> <span class=p>(</span><span class=n>f</span> <span class=o>.</span> <span class=n>g</span><span class=p>)</span>
</code></pre></div><p>Another popular usage is seen in lambda calculus, where <code>Alg</code> has kind <code>(* -> *) -> * -> *</code> enabling us to write recursion schemes on top of datatypes.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Alg</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Alg</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>
</code></pre></div><p>In languages like Java, you cannot write</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>ClassExample</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>a</span><span class=o>&gt;</span> <span class=o>{</span>
    <span class=n>T</span><span class=o>&lt;</span><span class=n>a</span><span class=o>&gt;</span> <span class=nf>function</span><span class=o>(</span><span class=o>)</span>
<span class=o>}</span>
</code></pre></div><p>In Haskell <code>T</code> would have kind <code>*->*</code>, but a Java type (i.e. class) cannot have a type parameter of that kind, a higher-kinded type.</p><p>Personally, I feel these concepts are better understood from the perspective of lambda calculus, parametric polymorphism with higher-rank types as System F, and higher-kinded types as System λω. Hopefully we can cover that in future.</p><p>Thanks!</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/lenses-part-1/>Haskell Lens - Part 1</a></li><li><a href=/posts/currying/>What is Currying</a></li><li><a href=/posts/foldables-traversals/>Foldable and Traversable in Haskell</a></li></ul></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=/about target=_blank>About</a></div><div class=site-footer-item><a href=https://github.com/namratachaudhary target=_blank>Github</a></div><div class=site-footer-item><a href=https://www.linkedin.com/in/namrata-c-542b8a56/ target=_blank>LinkedIn</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>