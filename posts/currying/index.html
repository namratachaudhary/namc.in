<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="/posts/currying/"><link rel=canonical href=/posts/currying/><link rel=alternate type=application/atom+xml href=/index.xml><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"What is Currying","headline":"What is Currying","description":"Inspiration This post is written after I saw this tweet\nEvery functional programming tutorial:\n\x26gt; OK, we\x26#39;re going to talk about currying. Currying is when you break down a function tha-\n*scrolls down*\n\x26gt; const Y = f =\x26gt; (g =\x26gt; g(g))(g =\x26gt; f(x =\x26gt; g(g)(x))) pic.twitter.com\/EPHH9SG5ay\n\x26mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2018","datePublished":"2018-02-22 12:07:52 \x2b0530 \x2b0530","dateModified":"2018-02-22 12:07:52 \x2b0530 \x2b0530","url":"\/posts\/currying\/","keywords":["Haskell"]}</script><title>What is Currying -</title><meta property="og:title" content="What is Currying -"><meta property="og:type" content="article"><meta property="og:description" content="Inspiration This post is written after I saw this tweet
Every functional programming tutorial:
> OK, we're going to talk about currying. Currying is when you break down a function tha-
*scrolls down*
> const Y = f => (g => g(g))(g => f(x => g(g)(x))) pic.twitter.com/EPHH9SG5ay
&mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage."><meta name=description content="Inspiration This post is written after I saw this tweet
Every functional programming tutorial:
> OK, we're going to talk about currying. Currying is when you break down a function tha-
*scrolls down*
> const Y = f => (g => g(g))(g => f(x => g(g)(x))) pic.twitter.com/EPHH9SG5ay
&mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>What is Currying</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-02-22 12:07:52 +0530">22 Feb 2018</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><h2 id=inspiration>Inspiration</h2><p>This post is written after I saw this tweet</p><blockquote class=twitter-tweet data-cards=hidden data-lang=en><p lang=en dir=ltr>Every functional programming tutorial:<br><br>> OK, we're going to talk about currying. Currying is when you break down a function tha-<br>*scrolls down*<br>> const Y = f => (g => g(g))(g => f(x => g(g)(x))) <a href=https://t.co/EPHH9SG5ay>pic.twitter.com/EPHH9SG5ay</a></p>&mdash; Ben Howdle (@ben_howdle) <a href="https://twitter.com/ben_howdle/status/966358609683668992?ref_src=twsrc%5Etfw">February 21, 2018</a></blockquote><p>And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage.</p><p>We will be using Haskell for this tutorial, but this can be extended to any functional programming language.</p><h2 id=higherorder-functions>Higher-order functions!</h2><p>In mathematics, higher-order functions (HOFs) are called functionals. But to simplify it for general software engineers, HOF is simply a functions that</p><ul><li>either takes a function as an argument</li><li>or returns a function as a result</li></ul><p>A well-known higher order function is map, which performs an action on each element in a collection, e.g.:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- Haskell</span>
<span class=nf>map</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>x</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span> <span class=c1>-- =&gt; [2, 4, 6, 8, 10]</span></code></pre></div><p>In usual imperative programming, functions can accept values, like integers and strings (first order functions) and and return a value of some other type.</p><p>Consider a function, <code>f</code> such that -</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>f</span> <span class=n>a</span> <span class=n>b</span> <span class=n>c</span> <span class=ow>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>-</span> <span class=n>c</span></code></pre></div><p>What if we wanted to generalize the operators in above function? That would make our operators a variable too. Right? Let's see a way to define a more generalized version of <code>f</code>, where <code>g</code> and <code>h</code> represent the operator-functions.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>let</span> <span class=n>f</span> <span class=n>g</span> <span class=n>h</span> <span class=n>a</span> <span class=n>b</span> <span class=n>c</span> <span class=ow>=</span> <span class=n>a</span> <span class=p>`</span><span class=n>g</span><span class=p>`</span> <span class=n>b</span> <span class=p>`</span><span class=n>h</span><span class=p>`</span> <span class=n>c</span>

<span class=o>&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=p>(</span><span class=o>-</span><span class=p>)</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=c1>-- returns 1</span>
<span class=o>&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=o>/</span><span class=p>)</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=c1>-- returns 1.5</span></code></pre></div><p>That was simple! But, we mentioned that HOFs can return a function too. Yes, we can create a function that accepts a function and an argument and returns another function, which accepts an argument and returns a result. For example :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>let</span> <span class=n>g</span> <span class=n>f</span> <span class=n>n</span> <span class=ow>=</span> <span class=p>(</span><span class=nf>\</span><span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>`</span><span class=n>f</span><span class=p>`</span> <span class=n>n</span><span class=p>)</span>

<span class=o>&gt;</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>g</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=mi>2</span>
<span class=o>&gt;</span> <span class=n>f</span> <span class=mi>10</span> <span class=c1>-- returns 12</span>

<span class=o>&gt;</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>g</span> <span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=mi>2</span>
<span class=o>&gt;</span> <span class=n>f</span> <span class=mi>10</span> <span class=c1>-- returns 20</span></code></pre></div><p>In the above example, <code>(\m -> m</code>f<code>n)</code> construct is an anonymous function of 1 argument <code>m</code> which applies <code>f</code> to <code>m</code> and <code>n</code>. And using this anonymous functions, we can define <code>g h 2</code> which is a function that accepts one argument <code>g</code> and operates <code>h</code> to it.</p><p>**Trivia : ** Scheme, according to Wikipedia, was the first language to introduce proper higher-order functions as first-class citizens, however the first mention dates back to Frege in "Funktion und Begriff" (1891).</p><h2 id=currying>Currying</h2><p>Currying is a technique that transforms a function of several arguments to a function of a single argument, which returns a function of 1 argument, which returns a functions of 1 argument ... till it returns a value.</p><p>A curried function is one that returns a function as its result. A fully curried function is a one-argument function that either returns an ordinary result or returns a fully curried function.</p><p>Note that a curried function is necessarily a higher-order function, since it returns a function as its result.</p><p>Let's take an example, where we have a function of two args, like (+). But what if you could define the same function, by giving only one argument to it, thereby returning a function, which you could use later to add thid 1st argument, now encased in this new function, to something else.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>f</span> <span class=n>n</span> <span class=ow>=</span> <span class=p>(</span><span class=nf>\</span><span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>n</span> <span class=o>+</span> <span class=n>m</span><span class=p>)</span>

<span class=o>&gt;</span> <span class=n>g</span> <span class=ow>=</span> <span class=n>f</span> <span class=mi>10</span>
<span class=o>&gt;</span> <span class=n>g</span> <span class=mi>8</span> <span class=c1>-- would return 18</span>
<span class=o>&gt;</span> <span class=n>g</span> <span class=mi>4</span> <span class=c1>-- would return 14</span></code></pre></div><p>Same can be written in javascript like :</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>add</span> <span class=p>(</span><span class=nx>a</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=nx>add</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</code></pre></div><p>How could be make it more abstract? Lets define <code>curry</code> , which takes a function and an argument, such that</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>curry</span> <span class=n>f</span> <span class=n>n</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>n</span> <span class=n>m</span>

<span class=nf>g</span> <span class=ow>=</span> <span class=n>curry</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=mi>5</span>
<span class=o>&gt;</span> <span class=n>g</span> <span class=mi>10</span> <span class=c1>-- returns 15</span>

<span class=nf>h</span> <span class=ow>=</span> <span class=n>curry</span> <span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=mi>5</span>
<span class=o>&gt;</span> <span class=n>g</span> <span class=mi>10</span> <span class=c1>-- returns 50</span></code></pre></div><p>If we check the type <code>:t</code> of <code>curry</code> function defined above, we find,</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>curry</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>c</span><span class=p>)</span></code></pre></div><h2 id=haskell-functions>Haskell functions</h2><p>Haskell curries all functions by default. There are no functions of multiple arguments in Haskell. What you have are only functions of one argument, some of which may return new functions of one arguments. So you can define a multi-argument function as you would in any other language and you automatically get a curried version of it, without having to write lamdas yourself.</p><p>For example, take the function <code>(++)</code> which concatenates two strings together.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kt>:</span><span class=n>t</span> <span class=p>(</span><span class=o>++</span><span class=p>)</span>
<span class=p>(</span><span class=o>++</span><span class=p>)</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span></code></pre></div><p>The type definition can be understood as, <code>(++)</code> accepts one list, and returns a function of type <code>[a] -> [a]</code>. The resultant function can accept yet another list, and we get a new list of type <code>[a]</code>.</p><p>If you are familiar with other languages, you can correlate <code>f a b c</code> as Lisp's <code>(((f a) b) c)</code> or Java's <code>f(a, b, c)</code> . This makes sense as , in Haskell, the function <code>f</code> is curried by default.</p><p>However, when you're analyzing types, the association is from right to left, so <code>[a] -> [a] -> [a]</code> is equivalent to <code>[a] -> ([a] -> [a])</code>, which means that when you apply an argument to the function, you get back a function of type <code>[a] -> [a]</code>.</p><p>Similiary, you can analyze <code>map</code>, which accepts a function <code>(a -> b)</code> and a list <code>[a]</code> , and returns a transformed list <code>[b]</code>, such that function is mapped over all elements of <code>[a]</code>.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kt>:</span><span class=n>t</span> <span class=n>map</span>
<span class=nf>map</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>b</span><span class=p>]</span></code></pre></div><p>Try the following snippet out in ghci</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=o>*</span><span class=p>)</span>
<span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=mi>5</span>
<span class=p>(</span><span class=o>*</span><span class=p>)</span> <span class=mi>5</span> <span class=mi>10</span>
<span class=nf>map</span>
<span class=nf>map</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>head</span> <span class=n>x</span><span class=p>)</span>
<span class=nf>map</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>head</span> <span class=n>x</span><span class=p>)</span> <span class=p>[</span><span class=s>&#34;</span><span class=s>hello</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>kitty</span><span class=s>&#34;</span><span class=p>]</span>
<span class=nf>map</span> <span class=n>head</span>
<span class=nf>map</span> <span class=n>head</span> <span class=p>[</span><span class=s>&#34;</span><span class=s>hello</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>kitty</span><span class=s>&#34;</span><span class=p>]</span></code></pre></div><h2 id=partial-application>Partial application</h2><p>Partial application is when you call a function with 1 or multiple arguments to get back a function that still accepts arguments. This allows us to write shorter and concise code.</p><p>Partial application can be used as a substitute for anonymous functions. Let's look at some examples.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>take</span> <span class=mi>2</span> <span class=n>x</span><span class=p>)</span>

<span class=c1>-- can be written as</span>
<span class=p>(</span><span class=n>take</span> <span class=mi>2</span><span class=p>)</span></code></pre></div><p>What if you want to use an operator, say <code>(+)</code> instead of <code>take</code>? For infix functions, you can partially apply it using <a href=https://wiki.haskell.org/Section_of_an_infix_operator>sections</a>.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=mi>2</span> <span class=o>+</span> <span class=n>x</span><span class=p>)</span>
<span class=c1>-- can be written as</span>
<span class=p>(</span><span class=mi>2</span><span class=o>+</span><span class=p>)</span>

<span class=c1>-- and</span>
<span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span>
<span class=c1>-- can be written as</span>
<span class=p>(</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span></code></pre></div><p>In place of <code>(+)</code> , you can use any binary function to define sections.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=nf>\</span><span class=n>xs</span> <span class=ow>-&gt;</span> <span class=mi>2</span> <span class=n>elem&#39;</span> <span class=n>xs</span><span class=p>)</span>

<span class=c1>-- can be written as</span>
<span class=p>(</span><span class=mi>2</span><span class=n>elem&#39;</span><span class=p>)</span></code></pre></div><p>The point to note here is , since every function is curried by default, and accepts one argument only, so sections can be used with any function. For example ,</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>let</span> <span class=n>f</span> <span class=n>a</span> <span class=n>b</span> <span class=n>c</span> <span class=n>d</span> <span class=ow>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span>

<span class=c1>-- such that f is (+)</span>

<span class=o>&gt;</span> <span class=p>(</span><span class=mi>2</span><span class=n>f</span><span class=p>)</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span> <span class=c1>-- returns 14</span></code></pre></div><h2 id=currying-and-pattern-matching>Currying and Pattern Matching</h2><p>We take for granted that we can have nested patterns and patterns over more than one term, when in reality for the purposes of a compiler the only thing you can do is branch on the top-level constructor of a single value. So the first stage of the compiler is to turn nested patterns (and patterns over more than one value) into simpler patterns.</p><p>Let's take an example, a naive algorithm might transform your function into something like this:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>myFunc</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>x</span> <span class=n>y</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>x</span> <span class=kr>of</span>
    <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
        <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=mi>0</span>
        <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>x</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>
    <span class=mi>1</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
        <span class=mi>1</span> <span class=ow>-&gt;</span> <span class=mi>1</span>
        <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>x</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>
    <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=n>x</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span></code></pre></div><p>As we can see, there are a lot of caveats in the above implementation.</p><ul><li>the <code>some_operation</code> term is repeated a lot</li><li>the function expects both arguments before it will even start to do a case at all</li></ul><p>Refer to <a href=https://www.classes.cs.uchicago.edu/archive/2011/spring/22620-1/papers/pettersson92.pdf>A Term Pattern-Match Compiler Inspired by Finite Automata Theory</a> for further discussions on how we can improve it.</p><p>Anyway, in the form below, it should actually be a bit more clear how the currying step happens. We can directly substitute for <code>x</code> in this expression to look at what <code>myFunc 0</code> does:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>myFunc</span> <span class=mi>0</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=mi>0</span> <span class=kr>of</span>
    <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
        <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=mi>0</span>
        <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>0</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>
    <span class=mi>1</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
        <span class=mi>1</span> <span class=ow>-&gt;</span> <span class=mi>1</span>
        <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>0</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>
    <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>0</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span></code></pre></div><p>Now this is still a lambda, so no further reduction is done.</p><p>We will need to change the definition of our function if we want GHC to do more computation after supplying only one argument. There's a time/space tradeoff here. So GHC leaves it in the programmer's hands to make this choice. For example, you could explicitly write</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>myFunc</span> <span class=mi>0</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
    <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=mi>0</span>
    <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>0</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>

<span class=nf>myFunc</span> <span class=mi>1</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
    <span class=mi>1</span> <span class=ow>-&gt;</span> <span class=mi>1</span>
    <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>1</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span>

<span class=nf>myFunc</span> <span class=n>x</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=n>x</span> <span class=p>`</span><span class=n>some_operation</span><span class=p>`</span> <span class=n>y</span></code></pre></div><p>and then <code>myFunc 0</code> would reduce to a much smaller expression.</p><h2 id=compositions>Compositions</h2><p>Compositions and Application operator are very handy for writing concise and flexible code.</p><ul><li><strong>Composition operator</strong> <code>(.)</code> chains functions together.</li><li><strong>Application operator</strong> <code>($)</code> applies function on the left side to the argument on the right side</li></ul><p><code>f $ x</code> is equivalent to <code>f x</code>. However <code>($)</code> has the lowest precedence of all operators, so we can use it to get rid of parentheses: <code>f (g x y)</code> is equivalent to <code>f $ g x y</code>.</p><p>It is also helpful when we need to apply multiple functions to the same argument:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>map</span> <span class=p>(</span><span class=o>$</span><span class=mi>2</span><span class=p>)</span> <span class=p>[</span><span class=p>(</span><span class=mi>2</span><span class=o>+</span><span class=p>)</span><span class=p>,</span> <span class=p>(</span><span class=mi>10</span><span class=o>-</span><span class=p>)</span><span class=p>,</span> <span class=p>(</span><span class=mi>20</span><span class=o>/</span><span class=p>)</span><span class=p>]</span>

<span class=c1>-- would yield</span>
<span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>10</span><span class=p>]</span></code></pre></div><p>The following expressions are all equivalent</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>f</span> <span class=p>(</span><span class=n>g</span> <span class=p>(</span><span class=n>h</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>   <span class=c1>-- 1</span>

<span class=p>(</span><span class=n>f</span> <span class=o>.</span> <span class=n>g</span> <span class=o>.</span> <span class=n>h</span><span class=p>)</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span><span class=p>)</span> <span class=c1>-- 2</span>

<span class=nf>f</span> <span class=o>$</span> <span class=n>g</span> <span class=o>$</span> <span class=n>h</span> <span class=o>$</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span>   <span class=c1>-- 3</span>

<span class=nf>f</span> <span class=o>.</span> <span class=n>g</span> <span class=o>.</span> <span class=n>h</span> <span class=o>$</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span>   <span class=c1>-- 4</span></code></pre></div><p><code>(.)</code> and <code>($)</code> are different things. More can be read about that here - <a href=http://learnyouahaskell.com/higher-order-functions#function-application>Learn you a haskell ($)</a></p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/foldables-traversals/>Foldable and Traversable in Haskell</a></li><li><a href=/posts/applicative-functors/>Haskell's Applicative Functors</a></li></ul></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>