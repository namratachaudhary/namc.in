<!doctype html><html lang=en><head><title>Foldable and Traversable in Haskell :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Foldable Foldable represents data structure type class that
 provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
 Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result."><meta name=keywords content="foldable,traversable,haskell"><meta name=robots content="noodp"><link rel=canonical href=/posts/foldables-traversals/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/pink.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/pink.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Foldable and Traversable in Haskell :: __namc —"><meta name=twitter:description content="Foldable Foldable represents data structure type class that
 provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
 Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Foldable and Traversable in Haskell :: __namc —"><meta property="og:description" content="Foldable Foldable represents data structure type class that
 provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
 Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result."><meta property="og:url" content="/posts/foldables-traversals/"><meta property="og:site_name" content="Foldable and Traversable in Haskell"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-01-24 12:07:52 +0530 +0530"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/foldables-traversals/>Foldable and Traversable in Haskell</a></h1><div class=post-meta><span class=post-date>January 24, 2018</span></div><span class=post-tags>#<a href=/tags/haskell/>Haskell</a>&nbsp;</span><div class=post-content><div><h2 id=foldable>Foldable<a href=#foldable class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Foldable represents data structure type class that</p><ul><li>provides a generalisation of list folding (foldr and friends).</li><li>provides operations derived from list foldings to arbitrary data structures</li></ul><p>You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.</p><ul><li>Get the product of a list</li><li>Get the max path value in a tree</li></ul><p>In short, <code>fold</code> can be understood as function to reduce a large structure into a single result.</p><h3 id=foldable-class>Foldable Class<a href=#foldable-class class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Foldable</span> t <span style=color:#66d9ef>where</span>
    foldMap 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Monoid</span> m <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> m
    fold 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Monoid</span> m <span style=color:#f92672>=&gt;</span> t m <span style=color:#f92672>-&gt;</span> m

    <span style=color:#75715e>-- following have default implementations:</span>
    foldr 	<span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> b
    foldr&#39; 	<span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> b
    foldl 	<span style=color:#f92672>::</span> (b <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> b
    foldl&#39; 	<span style=color:#f92672>::</span> (b <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> b
    foldr1 	<span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> a
    foldl1 	<span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> a

    toList 	<span style=color:#f92672>::</span> t a <span style=color:#f92672>-&gt;</span> [a]
    null 	<span style=color:#f92672>::</span> t a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
    length 	<span style=color:#f92672>::</span> t a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
    elem 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Eq</span> a <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
    maximum 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Ord</span> a <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> a
    minimum 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Ord</span> a <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> a
    sum 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Num</span> a <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> a
    product 	<span style=color:#f92672>::</span> <span style=color:#66d9ef>Num</span> a <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> a
</code></pre></div><p>Foldable is a great example of how monoids can help formulating good abstractions as we can see <code>fold</code> and <code>foldMap</code> require the elements of the Foldable to be Monoids.</p><p>Monoids simply define a zero element via <code>mempty</code> and an associative operation mappend for combining two Monoids into one. <code>mconcat</code> makes use of <code>mappend</code> and <code>mempty</code> in it&rsquo;s default implementation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Monoid</span> a <span style=color:#66d9ef>where</span>
    mempty  <span style=color:#f92672>::</span> a
    mappend <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> a
    mconcat <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> a

<span style=color:#75715e>---</span>
<span style=color:#a6e22e>mconcat</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> a
<span style=color:#a6e22e>mconcat</span> <span style=color:#f92672>=</span> foldr mappend mempty
</code></pre></div><p>Let&rsquo;s look at some examples :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> length [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#ae81ff>6</span>

<span style=color:#75715e>-- sum all elements of the list</span>

<span style=color:#75715e>-- just using map, without Foldable.</span>
<span style=color:#f92672>&gt;</span> summ xs <span style=color:#f92672>=</span> <span style=color:#66d9ef>let</span> ys <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>:</span> map (<span style=color:#a6e22e>\</span>(a,b)<span style=color:#f92672>-&gt;</span>a<span style=color:#f92672>+</span>b) (zip xs ys) <span style=color:#66d9ef>in</span> last ys
<span style=color:#f92672>&gt;</span> summ [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#ae81ff>55</span>

<span style=color:#75715e>-- using foldr</span>
<span style=color:#f92672>&gt;</span> foldr (<span style=color:#f92672>+</span>) <span style=color:#ae81ff>0</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#ae81ff>55</span>

<span style=color:#75715e>-- using sum</span>
<span style=color:#f92672>&gt;</span> sum [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#ae81ff>55</span>

<span style=color:#75715e>-- check if element exists</span>
<span style=color:#f92672>&gt;</span> elem <span style=color:#ae81ff>4</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#66d9ef>True</span>
</code></pre></div><p>Instead of thinking of <code>sum</code> as a function which is fmapped across a list and accumulating its elements with (+), Foldable and foldMap help us think of it as function which queries each element for its value and summarises the results using <code>Sum</code> monoid.</p><p>Monoidal summary perspective is important while using folds as it separates the details of data structure from the expected results.</p><h3 id=fold-and-foldmap>fold and foldMap<a href=#fold-and-foldmap class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Foldable has no laws of its own and they are mostly general-purpose, however, fold and foldMap use monoid homomorphism.</p><p>In the example above <code>tList</code> was a list of integers <code>[Int]</code> , where the <code>[]</code> is a Foldable. <code>Int</code> is not a Monoid. So as long as we do not use any function from Foldable that requires Monoid, it will work fine. But if you try to use <code>fold</code> or <code>foldMap</code> on tList, it will throw an error.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> foldr1 (<span style=color:#f92672>+</span>) [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#ae81ff>55</span>

<span style=color:#f92672>&gt;</span> fold [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#f92672>&lt;</span>interactive<span style=color:#f92672>&gt;:</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>:</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>:</span>
    <span style=color:#66d9ef>No</span> <span style=color:#66d9ef>instance</span> for (<span style=color:#66d9ef>Monoid</span> a0) arising from a use <span style=color:#66d9ef>of</span> <span style=color:#960050;background-color:#1e0010>‘</span>it<span style=color:#960050;background-color:#1e0010>’</span>
</code></pre></div><p>In order to solve this problem, we can wrap the integers in a Monoid, such as Sum or Product, and fold them.</p><p>And for that, we can use <code>foldMap</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> foldMap <span style=color:#66d9ef>Sum</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#66d9ef>Sum</span> {getSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>55</span>}
</code></pre></div><p>Thus, fold can be implemented in terms of foldMap, since while using foldMap, we need to provide a function to convert each item in list to a Monoid.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>fold</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Monoid</span> m <span style=color:#f92672>=&gt;</span> t m <span style=color:#f92672>-&gt;</span> m
<span style=color:#a6e22e>fold</span> xs <span style=color:#f92672>=</span> foldMap id xs
</code></pre></div><h3 id=tolist---list-like-folds>toList - List like folds<a href=#tolist---list-like-folds class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Any Foldable data structure can be converted to List using</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>toList</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Foldable</span> t <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> [a]
</code></pre></div><p>.. which is a part of Foldable. If you use toList , folding the resulting list will produce the same result than folding the original structure directly. We can use <code>foldMap</code> to define toList.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>toList</span> <span style=color:#f92672>=</span> foldMap (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> [x])
</code></pre></div><p>Also, lists are free monoid for Haskell types. This means, any value can be given to the monoid such that the information is neither added nor erased from the original data.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- Given a list xs :: [a]</span>

<span style=color:#a6e22e>xsFoldMap</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Monoid</span> m <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m) <span style=color:#f92672>-&gt;</span> m
<span style=color:#a6e22e>xsFoldMap</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>\</span>f <span style=color:#f92672>-&gt;</span> foldMap f xs
</code></pre></div><p>Since lists are free monoid, we can recover the original list xs by supplying <code>(\x->[x])</code> to xsFoldMap.</p><p>Since we know folding with Foldable operations will cause in some loss of information if the data structure is complex, using <code>toList</code> to implement folds make it possible to reconstruct the original structure.</p><h3 id=examples>Examples<a href=#examples class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>import</span> <span style=color:#66d9ef>qualified</span> Data.Set <span style=color:#66d9ef>as</span> S

<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>let</span> testSet <span style=color:#f92672>=</span> <span style=color:#66d9ef>S</span><span style=color:#f92672>.</span>fromList [<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#f92672>&gt;</span> testSet
<span style=color:#a6e22e>fromList</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>]

<span style=color:#75715e>-- using toList to define data structure as free monoid</span>
<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>import</span> Data.Foldable
<span style=color:#f92672>&gt;</span> toList testSet
[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>]

<span style=color:#75715e>-- using foldMap on list above result</span>
<span style=color:#f92672>&gt;</span> foldMap show testSet
<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>12345678910</span><span style=color:#e6db74>&#34;</span>

<span style=color:#f92672>&gt;</span> foldMap <span style=color:#66d9ef>Sum</span> tSet
<span style=color:#ae81ff>55</span>
</code></pre></div><h2 id=traversable>Traversable<a href=#traversable class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=derivation>Derivation<a href=#derivation class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Consider the following Functor and Foldable instances for lists:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    fmap <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>[]</span>     <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
    fmap f (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> f x <span style=color:#66d9ef>:</span> fmap f xs

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Foldable</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    foldMap <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>[]</span>     <span style=color:#f92672>=</span> mempty
    foldMap f (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> f x <span style=color:#f92672>&lt;&gt;</span> foldMap f xs
</code></pre></div><p>Both <code>fmap f</code> and <code>foldMap f</code> walks across the list and apply <code>f</code> to each element. However, <strong>fmap f</strong> collects the result by rebuilding the list, and <strong>foldMap f</strong> collects the result by combining them with <code>mappend</code>.</p><p>But if we have to add a condition to our traversal, we can add it as a <code>Maybe</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>deleteTens</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Num</span> a, <span style=color:#66d9ef>Ord</span> a) <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> a
<span style=color:#a6e22e>deleteTens</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> (mod x <span style=color:#ae81ff>10</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>Nothing</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>Just</span> x

<span style=color:#75715e>-- ghci</span>
<span style=color:#75715e>-- Here, fmap is the Functor, and deleteTens is our foldable</span>
<span style=color:#75715e>-- This results in [Maybe a]</span>
<span style=color:#f92672>&gt;</span> fmap deleteTens [<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>20</span>]
</code></pre></div><p>Why can&rsquo;t we use a direct <code>Foldable</code> ? Because Foldable would replace the structure of the original list with that of whatever Monoid we pick for folding, and we will not be able to get back the original list.</p><p>But now we need a way to convert <code>Maybe</code> to list. To do that, we can combine the Maybe contexts of the values and recreate the list structure withing the combined context.</p><p>To do that, we make use of a type class which combines Functor context : <code>Applicatives</code> . This leads us to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- sequenceA :: Applicative f =&gt; [f a] -&gt; f [a]</span>
<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Traversable</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    sequenceA <span style=color:#66d9ef>[]</span>     <span style=color:#f92672>=</span> pure <span style=color:#66d9ef>[]</span>
    sequenceA (u<span style=color:#66d9ef>:</span>us) <span style=color:#f92672>=</span> (<span style=color:#66d9ef>:</span>) <span style=color:#f92672>&lt;$&gt;</span> u <span style=color:#f92672>&lt;*&gt;</span> sequenceA us

<span style=color:#75715e>-- equivalently:</span>
<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Traversable</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    sequenceA us <span style=color:#f92672>=</span> foldr (<span style=color:#a6e22e>\</span>u v <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>:</span>) <span style=color:#f92672>&lt;$&gt;</span> u <span style=color:#f92672>&lt;*&gt;</span> v) (pure <span style=color:#66d9ef>[]</span>) us
</code></pre></div><ul><li>Traversable is to Applicative contexts what Foldable is to Monoid values.</li><li>Similary, sequenceA is analogous to fold as it creates a summary of context within a structure, and rebuild structure with new context.</li></ul><p>So how do we get the original list type back from <code>fmap deleteTens [0..20]</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>let</span> seqWithoutTens <span style=color:#f92672>=</span> sequenceA <span style=color:#f92672>.</span> fmap deleteTens
<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t seqWithoutTens
<span style=color:#a6e22e>seqWithoutTens</span>
  <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Num</span> a, <span style=color:#66d9ef>Ord</span> a, <span style=color:#66d9ef>Traversable</span> t) <span style=color:#f92672>=&gt;</span> t a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> (t a)

<span style=color:#f92672>&gt;</span> seqWithoutTens [<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>]
<span style=color:#66d9ef>Nothing</span>

<span style=color:#f92672>&gt;</span> rejectWithNegatives [<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>]
<span style=color:#66d9ef>Just</span> [<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>]
</code></pre></div><h3 id=traversable-class>Traversable class<a href=#traversable-class class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>Traversable</code> is another type classes in the Prelude that can be used for data structure manipulation. A Traversable represents data structure which can be traversed, collecting results at each stop.</p><p>However, Traversable does not provide us with a way to change the data.</p><p>Let&rsquo;s look at the typeclass</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Functor</span> t, <span style=color:#66d9ef>Foldable</span> t) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Traversable</span> t <span style=color:#66d9ef>where</span>
    traverse  <span style=color:#f92672>::</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> f (t b)
    sequenceA <span style=color:#f92672>::</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#f92672>=&gt;</span> t (f a) <span style=color:#f92672>-&gt;</span> f (t a)

    <span style=color:#75715e>-- These methods have default definitions.</span>
    <span style=color:#75715e>-- They are merely specialised versions of the other two.</span>
    mapM      <span style=color:#f92672>::</span> <span style=color:#66d9ef>Monad</span> m <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> m (t b)
    sequence  <span style=color:#f92672>::</span> <span style=color:#66d9ef>Monad</span> m <span style=color:#f92672>=&gt;</span> t (m a) <span style=color:#f92672>-&gt;</span> m (t a)
</code></pre></div><p>We will pretty much be using <code>traverse</code> and <code>sequenceA</code> for most of our operations.</p><p>And so, rewriting our Traversable instance to incorporate traverse and sequenceA :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Traversable</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
	<span style=color:#75715e>-- traverse</span>
    traverse <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>[]</span>     <span style=color:#f92672>=</span> pure <span style=color:#66d9ef>[]</span>
	traverse f (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> (<span style=color:#66d9ef>:</span>) <span style=color:#f92672>&lt;$&gt;</span> f x <span style=color:#f92672>&lt;*&gt;</span> traverse f xs

	<span style=color:#75715e>-- sequenceA</span>
	sequenceA <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> pure <span style=color:#66d9ef>[]</span>
	sequenceA (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> (<span style=color:#66d9ef>:</span>) <span style=color:#f92672>&lt;$&gt;</span> x <span style=color:#f92672>&lt;*&gt;</span> sequenceA xs
</code></pre></div><p>And if sequenceA is analogous to fold, traverse is analogous to foldMap.
They can be defined in terms of each other, and therefore a minimal implementation of Traversable would look like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Functor</span> t, <span style=color:#66d9ef>Foldable</span> t) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Traversable</span> t <span style=color:#66d9ef>where</span>
    traverse <span style=color:#f92672>::</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> f (t b)
    traverse f <span style=color:#f92672>=</span> sequenceA <span style=color:#f92672>.</span> fmap f

    sequenceA <span style=color:#f92672>::</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#f92672>=&gt;</span> t (f a) <span style=color:#f92672>-&gt;</span> f (t a)
    sequenceA <span style=color:#f92672>=</span> traverse id
</code></pre></div><p><strong>sequenceA</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> sequenceA [[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>a</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span>], [<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>c</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>d</span><span style=color:#e6db74>&#34;</span>]]
[[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>a</span><span style=color:#e6db74>&#34;</span>,<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>c</span><span style=color:#e6db74>&#34;</span>],[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>a</span><span style=color:#e6db74>&#34;</span>,<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>d</span><span style=color:#e6db74>&#34;</span>],[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span>,<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>c</span><span style=color:#e6db74>&#34;</span>],[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span>,<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>d</span><span style=color:#e6db74>&#34;</span>]]
</code></pre></div><p>sequenceA works similar to <code>sequence :: Monad m => [m a] -> m [a]</code> from Control.Monad , it just additionally takes the applicative effects, runs them on the list, and then gives us the result.</p><p>In above example, our resultant list is of 4 elements, each consisting of 2 elements, which is exactly the kind of output you would expect from combinging with <code>(&lt;*>)</code> by combining a 2x2 list.</p><p>sequence :: Monad m => [m a] -> m [a] from Control.Monad and sequenceA are doing the same thing. It simply takes the Applicative effects, runs them and pulls them out of the list.</p><p><strong>traverse</strong></p><p>The type of traverse, along with an example :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>traverse</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Applicative</span> f, <span style=color:#66d9ef>Traversable</span> t) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> f (t b)

<span style=color:#75715e>-- ghci</span>

<span style=color:#f92672>&gt;</span> traverse (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Just</span> (x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) [<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>4</span>]
<span style=color:#66d9ef>Just</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>]
</code></pre></div><p>traverse type resembles mapping functions. traverse allows traversals which add an extra layer of context on top of the structure. It is a slightly modified version of <code>(>>=)</code> . The structure below new layer matches the original original structure, but the values are changed obviously.</p><p>As you can see in example above, the result maintains the structure of <code>[0..4]</code></p><p><strong>Conclusive Properties</strong></p><p>This enables us to define a few properties of lens :</p><ul><li>Traversals traverse all elements and each element is traversed only once</li><li>Traversals do not involve any skips or repetitions</li><li>the structure of the original structure is retained, though the values may change</li></ul><h3 id=traversable-laws>Traversable Laws<a href=#traversable-laws class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=identity-law>Identity Law<a href=#identity-law class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Traversing with <code>Identity</code> constructor wraps the structure with Indentity, which changes nothing and the original structure can be recovered by <code>runIdentity</code> . Thus, Identity constructor is the identity traversal.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>newtype</span> <span style=color:#66d9ef>Identity</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> { runIdentity <span style=color:#f92672>::</span> a }

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> <span style=color:#66d9ef>Identity</span> <span style=color:#66d9ef>where</span>
    fmap f (<span style=color:#66d9ef>Identity</span> x) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> (f x)

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> <span style=color:#66d9ef>Identity</span> <span style=color:#66d9ef>where</span>
    pure x <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> x
    <span style=color:#66d9ef>Identity</span> f <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Identity</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> (f x)

<span style=color:#75715e>-- formulating</span>
<span style=color:#a6e22e>traverse</span> <span style=color:#66d9ef>Identity</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span>
<span style=color:#a6e22e>sequenceA</span> <span style=color:#f92672>.</span> fmap <span style=color:#66d9ef>Identity</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span>
</code></pre></div><h4 id=composition-law>Composition Law<a href=#composition-law class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>Compose</code> is used to form composition of functors, but if we compose two Applicatives, we get an Applicative as result.</p><p>As per composition law, it does not matter whether the two traversals are performed separately or if they are composed in order to walk the structure only once.</p><p>The composition law is stated in terms of the Compose functor:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>newtype</span> <span style=color:#66d9ef>Compose</span> f g a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> { getCompose <span style=color:#f92672>::</span> f (g a) }

<span style=color:#66d9ef>instance</span> (<span style=color:#66d9ef>Functor</span> f, <span style=color:#66d9ef>Functor</span> g) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Functor</span> (<span style=color:#66d9ef>Compose</span> f g) <span style=color:#66d9ef>where</span>
    fmap f (<span style=color:#66d9ef>Compose</span> x) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> (fmap (fmap f) x)

<span style=color:#66d9ef>instance</span> (<span style=color:#66d9ef>Applicative</span> f, <span style=color:#66d9ef>Applicative</span> g) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Applicative</span> (<span style=color:#66d9ef>Compose</span> f g) <span style=color:#66d9ef>where</span>
    pure x <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> (pure (pure x))
    <span style=color:#66d9ef>Compose</span> f <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Compose</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> ((<span style=color:#f92672>&lt;*&gt;</span>) <span style=color:#f92672>&lt;$&gt;</span> f <span style=color:#f92672>&lt;*&gt;</span> x)

<span style=color:#75715e>-- formulating</span>
<span style=color:#a6e22e>traverse</span> (<span style=color:#66d9ef>Compose</span> <span style=color:#f92672>.</span> fmap g <span style=color:#f92672>.</span> f) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> <span style=color:#f92672>.</span> fmap (traverse g) <span style=color:#f92672>.</span> traverse f
<span style=color:#a6e22e>sequenceA</span> <span style=color:#f92672>.</span> fmap <span style=color:#66d9ef>Compose</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Compose</span> <span style=color:#f92672>.</span> fmap sequenceA <span style=color:#f92672>.</span> sequenceA
</code></pre></div><h4 id=applicative-homomorphism-law>Applicative Homomorphism Law<a href=#applicative-homomorphism-law class=hanchor arialabel=Anchor>&#8983;</a></h4><p>An applicative homomorphism is analogoues to <a href=https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms>Monoid homomorphisms</a>, and it is a function which preserves the Applicative operations, such that:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- Given a choice of f and g, and for any a,</span>
<span style=color:#a6e22e>t</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Applicative</span> f, <span style=color:#66d9ef>Applicative</span> g) <span style=color:#f92672>=&gt;</span> f a <span style=color:#f92672>-&gt;</span> g a

<span style=color:#a6e22e>t</span> (pure x) <span style=color:#f92672>=</span> pure x
<span style=color:#a6e22e>t</span> (x <span style=color:#f92672>&lt;*&gt;</span> y) <span style=color:#f92672>=</span> t x <span style=color:#f92672>&lt;*&gt;</span> t y

<span style=color:#75715e>-- formulating</span>
<span style=color:#a6e22e>t</span> <span style=color:#f92672>.</span> traverse f <span style=color:#f92672>=</span> traverse (t <span style=color:#f92672>.</span> f)
<span style=color:#a6e22e>t</span> <span style=color:#f92672>.</span> sequenceA <span style=color:#f92672>=</span> sequenceA <span style=color:#f92672>.</span> fmap t
</code></pre></div><h2 id=implementation-for-foldable-using-traversable>Implementation for Foldable using Traversable<a href=#implementation-for-foldable-using-traversable class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Traversable allows us to define Functor and Foldable, i.e. implement both <code>fmap</code> and <code>foldMap</code> using <code>traverse</code> as long as Traversable instance follows the laws.</p><h4 id=fmap>fmap<a href=#fmap class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Comparing fmap with traverse :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>fmap</span> 	 <span style=color:#f92672>::</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b
<span style=color:#a6e22e>traverse</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Traversable</span> t, <span style=color:#66d9ef>Applicative</span> f) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> f (t b)
</code></pre></div><p>In <code>traverse</code> the function that is passed returns a value wrapped in Applicative context, and the result obtained from traverse is also wrapped.</p><p>We can Identity functor to wrap the value after we apply the functor and then unwrap it at the end (using <code>runIdentity :: Identity a -> a</code>), to get the exact same type as fmap. Thus, using Idenity to make traversal out of an arbitrary function, we get :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>fmap</span> f <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>.</span> traverse (<span style=color:#66d9ef>Identity</span> <span style=color:#f92672>.</span> f)
</code></pre></div><h4 id=foldmap>foldMap<a href=#foldmap class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Comparing foldMap with traverse :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>foldMap</span>  <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Traversable</span> t, <span style=color:#66d9ef>Monoid</span> m) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> m
<span style=color:#a6e22e>traverse</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Traversable</span> t, <span style=color:#66d9ef>Applicative</span> f) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> f (t b)
</code></pre></div><p>We need a way to convert each element of Traversable to a Monoid. To do this, we will use <code>Const</code> from Control.Applicative.</p><p><code>Const</code> is a constant functor such that, the value of type <code>Const a b</code> holds value <code>a</code> which is unaffected by <code>fmap</code> . To define <code>foldMap</code> , <code>a</code> value would be an Applicative, such that :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Monoid</span> a <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Applicative</span> (<span style=color:#66d9ef>Const</span> a) <span style=color:#66d9ef>where</span>
    pure <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Const</span> mempty
    <span style=color:#66d9ef>Const</span> x <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Const</span> y <span style=color:#f92672>=</span> <span style=color:#66d9ef>Const</span> (x `mappend` y)

<span style=color:#75715e>-- (&lt;*&gt;) combines the values in each context with mappend</span>
</code></pre></div><p>In order to make a traversal out of any <code>Monoid m => a -> m</code> function, we can define foldMap as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>foldMap</span> f <span style=color:#f92672>=</span> getConst <span style=color:#f92672>.</span> traverse (<span style=color:#66d9ef>Const</span> <span style=color:#f92672>.</span> f)
</code></pre></div><h4 id=foldable-1>Foldable<a href=#foldable-1 class=hanchor arialabel=Anchor>&#8983;</a></h4><p>After defining <code>fmap</code> and <code>foldMap</code>, we can use them to define a Functor and a Foldable instance for any Traversable.</p><p>For example, let&rsquo;s take a simple list type :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- our definitions</span>

<span style=color:#a6e22e>fmap&#39;</span> f    <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>.</span> traverse (<span style=color:#66d9ef>Identity</span> <span style=color:#f92672>.</span> f)
<span style=color:#a6e22e>foldMap&#39;</span> f <span style=color:#f92672>=</span> getConst <span style=color:#f92672>.</span> traverse (<span style=color:#66d9ef>Const</span> <span style=color:#f92672>.</span> f)

<span style=color:#75715e>-- defining Functor and Foldable instance for List</span>

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>List</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nil</span>
            <span style=color:#f92672>|</span> <span style=color:#66d9ef>Cons</span> a (<span style=color:#66d9ef>List</span> a)
            <span style=color:#66d9ef>deriving</span> <span style=color:#66d9ef>Show</span>

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> <span style=color:#66d9ef>List</span> <span style=color:#66d9ef>where</span>
    fmap <span style=color:#f92672>=</span> fmap&#39;

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Foldable</span> <span style=color:#66d9ef>List</span> <span style=color:#66d9ef>where</span>
    foldMap <span style=color:#f92672>=</span> foldMap&#39;

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Traversable</span> <span style=color:#66d9ef>List</span> <span style=color:#66d9ef>where</span>
    traverse <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>Nil</span> <span style=color:#f92672>=</span> pure <span style=color:#66d9ef>Nil</span>
    traverse f (<span style=color:#66d9ef>Cons</span> x xs) <span style=color:#f92672>=</span> fmap <span style=color:#66d9ef>Cons</span> (f x) <span style=color:#f92672>&lt;*&gt;</span> traverse f xs
</code></pre></div><p>Checking how it works on ghci :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> traverse (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Just</span> (x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>1</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>2</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>Nil</span>)))
<span style=color:#66d9ef>Just</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>2</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>3</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>4</span> <span style=color:#66d9ef>Nil</span>)))

<span style=color:#f92672>&gt;</span> fold (<span style=color:#66d9ef>Cons</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>hello</span><span style=color:#e6db74>&#34;</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>haskell</span><span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>Nil</span>))
<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>hellohaskell</span><span style=color:#e6db74>&#34;</span>

<span style=color:#f92672>&gt;</span> fmap (<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>1</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>2</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>Nil</span>)))
<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>2</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>3</span> (<span style=color:#66d9ef>Cons</span> <span style=color:#ae81ff>4</span> <span style=color:#66d9ef>Nil</span>))
</code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/currying/><span class=button__icon>←</span>
<span class=button__text>What is Currying</span></a></span>
<span class="button next"><a href=/posts/applicative-functors/><span class=button__text>Haskell's Applicative Functors</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>