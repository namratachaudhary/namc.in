<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="__namc"><meta property="og:url" content="/posts/foldables-traversals/"><link rel=canonical href=/posts/foldables-traversals/><link rel=alternate type=application/atom+xml href=/index.xml title="Namc's blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Foldable and Traversable in Haskell","headline":"Foldable and Traversable in Haskell","description":"Foldable Foldable represents data structure type class that\n provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.\n Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result.","inLanguage":"en-US","author":"__namc","creator":"__namc","publisher":"__namc","accountablePerson":"__namc","copyrightHolder":"__namc","copyrightYear":"2018","datePublished":"2018-01-24 12:07:52 \x2b0530 \x2b0530","dateModified":"2018-01-24 12:07:52 \x2b0530 \x2b0530","url":"\/posts\/foldables-traversals\/","keywords":["Haskell"]}</script><title>Foldable and Traversable in Haskell - Namc's blog</title><meta property="og:title" content="Foldable and Traversable in Haskell - Namc's blog"><meta property="og:type" content="article"><meta property="og:description" content="Foldable Foldable represents data structure type class that
 provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
 Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result."><meta name=description content="Foldable Foldable represents data structure type class that
 provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures  You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
 Get the product of a list Get the max path value in a tree  In short, fold can be understood as function to reduce a large structure into a single result."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Namc's blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Foldable and Traversable in Haskell</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-01-24 12:07:52 +0530">24 Jan 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://namc.in/>@__namc</a></div></div></div></header><div class="post-content markdown-body"><h2 id=foldable>Foldable</h2><p>Foldable represents data structure type class that</p><ul><li>provides a generalisation of list folding (foldr and friends).</li><li>provides operations derived from list foldings to arbitrary data structures</li></ul><p>You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.</p><ul><li>Get the product of a list</li><li>Get the max path value in a tree</li></ul><p>In short, <code>fold</code> can be understood as function to reduce a large structure into a single result.</p><h3 id=foldable-class>Foldable Class</h3><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>class</span> <span class=kt>Foldable</span> <span class=n>t</span> <span class=kr>where</span>
    <span class=n>foldMap</span> 	<span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span>
    <span class=n>fold</span> 	<span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>m</span>

    <span class=c1>-- following have default implementations:</span>
    <span class=n>foldr</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span>
    <span class=n>foldr&#39;</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span>
    <span class=n>foldl</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span>
    <span class=n>foldl&#39;</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span>
    <span class=n>foldr1</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=n>foldl1</span> 	<span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>

    <span class=n>toList</span> 	<span class=ow>::</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span>
    <span class=n>null</span> 	<span class=ow>::</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Bool</span>
    <span class=n>length</span> 	<span class=ow>::</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Int</span>
    <span class=n>elem</span> 	<span class=ow>::</span> <span class=kt>Eq</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Bool</span>
    <span class=n>maximum</span> 	<span class=ow>::</span> <span class=kt>Ord</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=n>minimum</span> 	<span class=ow>::</span> <span class=kt>Ord</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=n>sum</span> 	<span class=ow>::</span> <span class=kt>Num</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=n>product</span> 	<span class=ow>::</span> <span class=kt>Num</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</code></pre></div><p>Foldable is a great example of how monoids can help formulating good abstractions as we can see <code>fold</code> and <code>foldMap</code> require the elements of the Foldable to be Monoids.</p><p>Monoids simply define a zero element via <code>mempty</code> and an associative operation mappend for combining two Monoids into one. <code>mconcat</code> makes use of <code>mappend</code> and <code>mempty</code> in it&rsquo;s default implementation.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>class</span> <span class=kt>Monoid</span> <span class=n>a</span> <span class=kr>where</span>
    <span class=n>mempty</span>  <span class=ow>::</span> <span class=n>a</span>
    <span class=n>mappend</span> <span class=ow>::</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=n>mconcat</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>

<span class=c1>---</span>
<span class=nf>mconcat</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>
<span class=nf>mconcat</span> <span class=ow>=</span> <span class=n>foldr</span> <span class=n>mappend</span> <span class=n>mempty</span>
</code></pre></div><p>Let&rsquo;s look at some examples :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>length</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=mi>6</span>

<span class=c1>-- sum all elements of the list</span>

<span class=c1>-- just using map, without Foldable.</span>
<span class=o>&gt;</span> <span class=n>summ</span> <span class=n>xs</span> <span class=ow>=</span> <span class=kr>let</span> <span class=n>ys</span> <span class=ow>=</span> <span class=mi>0</span> <span class=kt>:</span> <span class=n>map</span> <span class=p>(</span><span class=nf>\</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span><span class=ow>-&gt;</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=n>zip</span> <span class=n>xs</span> <span class=n>ys</span><span class=p>)</span> <span class=kr>in</span> <span class=n>last</span> <span class=n>ys</span>
<span class=o>&gt;</span> <span class=n>summ</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=mi>55</span>

<span class=c1>-- using foldr</span>
<span class=o>&gt;</span> <span class=n>foldr</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=mi>0</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=mi>55</span>

<span class=c1>-- using sum</span>
<span class=o>&gt;</span> <span class=n>sum</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=mi>55</span>

<span class=c1>-- check if element exists</span>
<span class=o>&gt;</span> <span class=n>elem</span> <span class=mi>4</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=kt>True</span>
</code></pre></div><p>Instead of thinking of <code>sum</code> as a function which is fmapped across a list and accumulating its elements with (+), Foldable and foldMap help us think of it as function which queries each element for its value and summarises the results using <code>Sum</code> monoid.</p><p>Monoidal summary perspective is important while using folds as it separates the details of data structure from the expected results.</p><h3 id=fold-and-foldmap>fold and foldMap</h3><p>Foldable has no laws of its own and they are mostly general-purpose, however, fold and foldMap use monoid homomorphism.</p><p>In the example above <code>tList</code> was a list of integers <code>[Int]</code> , where the <code>[]</code> is a Foldable. <code>Int</code> is not a Monoid. So as long as we do not use any function from Foldable that requires Monoid, it will work fine. But if you try to use <code>fold</code> or <code>foldMap</code> on tList, it will throw an error.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>foldr1</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=mi>55</span>

<span class=o>&gt;</span> <span class=n>fold</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=o>&lt;</span><span class=n>interactive</span><span class=o>&gt;:</span><span class=mi>1</span><span class=kt>:</span><span class=mi>1</span><span class=kt>:</span>
    <span class=kt>No</span> <span class=kr>instance</span> <span class=n>for</span> <span class=p>(</span><span class=kt>Monoid</span> <span class=n>a0</span><span class=p>)</span> <span class=n>arising</span> <span class=n>from</span> <span class=n>a</span> <span class=n>use</span> <span class=kr>of</span> <span class=err>‘</span><span class=n>it</span><span class=err>’</span>
</code></pre></div><p>In order to solve this problem, we can wrap the integers in a Monoid, such as Sum or Product, and fold them.</p><p>And for that, we can use <code>foldMap</code></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>foldMap</span> <span class=kt>Sum</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=kt>Sum</span> <span class=p>{</span><span class=n>getSum</span> <span class=ow>=</span> <span class=mi>55</span><span class=p>}</span>
</code></pre></div><p>Thus, fold can be implemented in terms of foldMap, since while using foldMap, we need to provide a function to convert each item in list to a Monoid.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>fold</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>m</span> <span class=ow>-&gt;</span> <span class=n>m</span>
<span class=nf>fold</span> <span class=n>xs</span> <span class=ow>=</span> <span class=n>foldMap</span> <span class=n>id</span> <span class=n>xs</span>
</code></pre></div><h3 id=tolist---list-like-folds>toList - List like folds</h3><p>Any Foldable data structure can be converted to List using</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>toList</span> <span class=ow>::</span> <span class=kt>Foldable</span> <span class=n>t</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span>
</code></pre></div><p>.. which is a part of Foldable. If you use toList , folding the resulting list will produce the same result than folding the original structure directly. We can use <code>foldMap</code> to define toList.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>toList</span> <span class=ow>=</span> <span class=n>foldMap</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><p>Also, lists are free monoid for Haskell types. This means, any value can be given to the monoid such that the information is neither added nor erased from the original data.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- Given a list xs :: [a]</span>

<span class=nf>xsFoldMap</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span>
<span class=nf>xsFoldMap</span> <span class=ow>=</span> <span class=nf>\</span><span class=n>f</span> <span class=ow>-&gt;</span> <span class=n>foldMap</span> <span class=n>f</span> <span class=n>xs</span>
</code></pre></div><p>Since lists are free monoid, we can recover the original list xs by supplying <code>(\x->[x])</code> to xsFoldMap.</p><p>Since we know folding with Foldable operations will cause in some loss of information if the data structure is complex, using <code>toList</code> to implement folds make it possible to reconstruct the original structure.</p><h3 id=examples>Examples</h3><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=kr>import</span> <span class=k>qualified</span> <span class=nn>Data.Set</span> <span class=k>as</span> <span class=n>S</span>

<span class=o>&gt;</span> <span class=kr>let</span> <span class=n>testSet</span> <span class=ow>=</span> <span class=kt>S</span><span class=o>.</span><span class=n>fromList</span> <span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=o>&gt;</span> <span class=n>testSet</span>
<span class=nf>fromList</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>10</span><span class=p>]</span>

<span class=c1>-- using toList to define data structure as free monoid</span>
<span class=o>&gt;</span> <span class=kr>import</span> <span class=nn>Data.Foldable</span>
<span class=o>&gt;</span> <span class=n>toList</span> <span class=n>testSet</span>
<span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>10</span><span class=p>]</span>

<span class=c1>-- using foldMap on list above result</span>
<span class=o>&gt;</span> <span class=n>foldMap</span> <span class=n>show</span> <span class=n>testSet</span>
<span class=s>&#34;</span><span class=s>12345678910</span><span class=s>&#34;</span>

<span class=o>&gt;</span> <span class=n>foldMap</span> <span class=kt>Sum</span> <span class=n>tSet</span>
<span class=mi>55</span>
</code></pre></div><h2 id=traversable>Traversable</h2><h3 id=derivation>Derivation</h3><p>Consider the following Functor and Foldable instances for lists:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>[]</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=kr>_</span> <span class=kt>[]</span>     <span class=ow>=</span> <span class=kt>[]</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span> <span class=kt>:</span> <span class=n>fmap</span> <span class=n>f</span> <span class=n>xs</span>

<span class=kr>instance</span> <span class=kt>Foldable</span> <span class=kt>[]</span> <span class=kr>where</span>
    <span class=n>foldMap</span> <span class=kr>_</span> <span class=kt>[]</span>     <span class=ow>=</span> <span class=n>mempty</span>
    <span class=n>foldMap</span> <span class=n>f</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span> <span class=o>&lt;&gt;</span> <span class=n>foldMap</span> <span class=n>f</span> <span class=n>xs</span>
</code></pre></div><p>Both <code>fmap f</code> and <code>foldMap f</code> walks across the list and apply <code>f</code> to each element. However, <strong>fmap f</strong> collects the result by rebuilding the list, and <strong>foldMap f</strong> collects the result by combining them with <code>mappend</code>.</p><p>But if we have to add a condition to our traversal, we can add it as a <code>Maybe</code>:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>deleteTens</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Num</span> <span class=n>a</span><span class=p>,</span> <span class=kt>Ord</span> <span class=n>a</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Maybe</span> <span class=n>a</span>
<span class=nf>deleteTens</span> <span class=n>x</span> <span class=ow>=</span> <span class=kr>if</span> <span class=p>(</span><span class=n>mod</span> <span class=n>x</span> <span class=mi>10</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=kr>then</span> <span class=kt>Nothing</span> <span class=kr>else</span> <span class=kt>Just</span> <span class=n>x</span>

<span class=c1>-- ghci</span>
<span class=c1>-- Here, fmap is the Functor, and deleteTens is our foldable</span>
<span class=c1>-- This results in [Maybe a]</span>
<span class=o>&gt;</span> <span class=n>fmap</span> <span class=n>deleteTens</span> <span class=p>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>20</span><span class=p>]</span>
</code></pre></div><p>Why can&rsquo;t we use a direct <code>Foldable</code> ? Because Foldable would replace the structure of the original list with that of whatever Monoid we pick for folding, and we will not be able to get back the original list.</p><p>But now we need a way to convert <code>Maybe</code> to list. To do that, we can combine the Maybe contexts of the values and recreate the list structure withing the combined context.</p><p>To do that, we make use of a type class which combines Functor context : <code>Applicatives</code> . This leads us to</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- sequenceA :: Applicative f =&gt; [f a] -&gt; f [a]</span>
<span class=kr>instance</span> <span class=kt>Traversable</span> <span class=kt>[]</span> <span class=kr>where</span>
    <span class=n>sequenceA</span> <span class=kt>[]</span>     <span class=ow>=</span> <span class=n>pure</span> <span class=kt>[]</span>
    <span class=n>sequenceA</span> <span class=p>(</span><span class=n>u</span><span class=kt>:</span><span class=n>us</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>:</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>u</span> <span class=o>&lt;*&gt;</span> <span class=n>sequenceA</span> <span class=n>us</span>

<span class=c1>-- equivalently:</span>
<span class=kr>instance</span> <span class=kt>Traversable</span> <span class=kt>[]</span> <span class=kr>where</span>
    <span class=n>sequenceA</span> <span class=n>us</span> <span class=ow>=</span> <span class=n>foldr</span> <span class=p>(</span><span class=nf>\</span><span class=n>u</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>:</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>u</span> <span class=o>&lt;*&gt;</span> <span class=n>v</span><span class=p>)</span> <span class=p>(</span><span class=n>pure</span> <span class=kt>[]</span><span class=p>)</span> <span class=n>us</span>
</code></pre></div><ul><li>Traversable is to Applicative contexts what Foldable is to Monoid values.</li><li>Similary, sequenceA is analogous to fold as it creates a summary of context within a structure, and rebuild structure with new context.</li></ul><p>So how do we get the original list type back from <code>fmap deleteTens [0..20]</code></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=kr>let</span> <span class=n>seqWithoutTens</span> <span class=ow>=</span> <span class=n>sequenceA</span> <span class=o>.</span> <span class=n>fmap</span> <span class=n>deleteTens</span>
<span class=o>&gt;</span> <span class=kt>:</span><span class=n>t</span> <span class=n>seqWithoutTens</span>
<span class=nf>seqWithoutTens</span>
  <span class=ow>::</span> <span class=p>(</span><span class=kt>Num</span> <span class=n>a</span><span class=p>,</span> <span class=kt>Ord</span> <span class=n>a</span><span class=p>,</span> <span class=kt>Traversable</span> <span class=n>t</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Maybe</span> <span class=p>(</span><span class=n>t</span> <span class=n>a</span><span class=p>)</span>

<span class=o>&gt;</span> <span class=n>seqWithoutTens</span> <span class=p>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>10</span><span class=p>]</span>
<span class=kt>Nothing</span>

<span class=o>&gt;</span> <span class=n>rejectWithNegatives</span> <span class=p>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>5</span><span class=p>]</span>
<span class=kt>Just</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>]</span>
</code></pre></div><h3 id=traversable-class>Traversable class</h3><p><code>Traversable</code> is another type classes in the Prelude that can be used for data structure manipulation. A Traversable represents data structure which can be traversed, collecting results at each stop.</p><p>However, Traversable does not provide us with a way to change the data.</p><p>Let&rsquo;s look at the typeclass</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>class</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>t</span><span class=p>,</span> <span class=kt>Foldable</span> <span class=n>t</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Traversable</span> <span class=n>t</span> <span class=kr>where</span>
    <span class=n>traverse</span>  <span class=ow>::</span> <span class=kt>Applicative</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>
    <span class=n>sequenceA</span> <span class=ow>::</span> <span class=kt>Applicative</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>a</span><span class=p>)</span>

    <span class=c1>-- These methods have default definitions.</span>
    <span class=c1>-- They are merely specialised versions of the other two.</span>
    <span class=n>mapM</span>      <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>
    <span class=n>sequence</span>  <span class=ow>::</span> <span class=kt>Monad</span> <span class=n>m</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=p>(</span><span class=n>m</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>m</span> <span class=p>(</span><span class=n>t</span> <span class=n>a</span><span class=p>)</span>
</code></pre></div><p>We will pretty much be using <code>traverse</code> and <code>sequenceA</code> for most of our operations.</p><p>And so, rewriting our Traversable instance to incorporate traverse and sequenceA :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>instance</span> <span class=kt>Traversable</span> <span class=kt>[]</span> <span class=kr>where</span>
	<span class=c1>-- traverse</span>
    <span class=n>traverse</span> <span class=kr>_</span> <span class=kt>[]</span>     <span class=ow>=</span> <span class=n>pure</span> <span class=kt>[]</span>
	<span class=n>traverse</span> <span class=n>f</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>:</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>f</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>traverse</span> <span class=n>f</span> <span class=n>xs</span>

	<span class=c1>-- sequenceA</span>
	<span class=n>sequenceA</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=n>pure</span> <span class=kt>[]</span>
	<span class=n>sequenceA</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=kt>:</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>sequenceA</span> <span class=n>xs</span>
</code></pre></div><p>And if sequenceA is analogous to fold, traverse is analogous to foldMap.
They can be defined in terms of each other, and therefore a minimal implementation of Traversable would look like:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>class</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>t</span><span class=p>,</span> <span class=kt>Foldable</span> <span class=n>t</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Traversable</span> <span class=n>t</span> <span class=kr>where</span>
    <span class=n>traverse</span> <span class=ow>::</span> <span class=kt>Applicative</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>
    <span class=n>traverse</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>sequenceA</span> <span class=o>.</span> <span class=n>fmap</span> <span class=n>f</span>

    <span class=n>sequenceA</span> <span class=ow>::</span> <span class=kt>Applicative</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=n>t</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>a</span><span class=p>)</span>
    <span class=n>sequenceA</span> <span class=ow>=</span> <span class=n>traverse</span> <span class=n>id</span>
</code></pre></div><p><strong>sequenceA</strong></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>sequenceA</span> <span class=p>[</span><span class=p>[</span><span class=s>&#34;</span><span class=s>a</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>b</span><span class=s>&#34;</span><span class=p>]</span><span class=p>,</span> <span class=p>[</span><span class=s>&#34;</span><span class=s>c</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;</span><span class=s>d</span><span class=s>&#34;</span><span class=p>]</span><span class=p>]</span>
<span class=p>[</span><span class=p>[</span><span class=s>&#34;</span><span class=s>a</span><span class=s>&#34;</span><span class=p>,</span><span class=s>&#34;</span><span class=s>c</span><span class=s>&#34;</span><span class=p>]</span><span class=p>,</span><span class=p>[</span><span class=s>&#34;</span><span class=s>a</span><span class=s>&#34;</span><span class=p>,</span><span class=s>&#34;</span><span class=s>d</span><span class=s>&#34;</span><span class=p>]</span><span class=p>,</span><span class=p>[</span><span class=s>&#34;</span><span class=s>b</span><span class=s>&#34;</span><span class=p>,</span><span class=s>&#34;</span><span class=s>c</span><span class=s>&#34;</span><span class=p>]</span><span class=p>,</span><span class=p>[</span><span class=s>&#34;</span><span class=s>b</span><span class=s>&#34;</span><span class=p>,</span><span class=s>&#34;</span><span class=s>d</span><span class=s>&#34;</span><span class=p>]</span><span class=p>]</span>
</code></pre></div><p>sequenceA works similar to <code>sequence :: Monad m => [m a] -> m [a]</code> from Control.Monad , it just additionally takes the applicative effects, runs them on the list, and then gives us the result.</p><p>In above example, our resultant list is of 4 elements, each consisting of 2 elements, which is exactly the kind of output you would expect from combinging with <code>(&lt;*>)</code> by combining a 2x2 list.</p><p>sequence :: Monad m => [m a] -> m [a] from Control.Monad and sequenceA are doing the same thing. It simply takes the Applicative effects, runs them and pulls them out of the list.</p><p><strong>traverse</strong></p><p>The type of traverse, along with an example :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>traverse</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Applicative</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Traversable</span> <span class=n>t</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>

<span class=c1>-- ghci</span>

<span class=o>&gt;</span> <span class=n>traverse</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=kt>Just</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span><span class=p>)</span> <span class=p>[</span><span class=mi>0</span><span class=o>..</span><span class=mi>4</span><span class=p>]</span>
<span class=kt>Just</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>]</span>
</code></pre></div><p>traverse type resembles mapping functions. traverse allows traversals which add an extra layer of context on top of the structure. It is a slightly modified version of <code>(>>=)</code> . The structure below new layer matches the original original structure, but the values are changed obviously.</p><p>As you can see in example above, the result maintains the structure of <code>[0..4]</code></p><p><strong>Conclusive Properties</strong></p><p>This enables us to define a few properties of lens :</p><ul><li>Traversals traverse all elements and each element is traversed only once</li><li>Traversals do not involve any skips or repetitions</li><li>the structure of the original structure is retained, though the values may change</li></ul><h3 id=traversable-laws>Traversable Laws</h3><h4 id=identity-law>Identity Law</h4><p>Traversing with <code>Identity</code> constructor wraps the structure with Indentity, which changes nothing and the original structure can be recovered by <code>runIdentity</code> . Thus, Identity constructor is the identity traversal.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>newtype</span> <span class=kt>Identity</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>{</span> <span class=n>runIdentity</span> <span class=ow>::</span> <span class=n>a</span> <span class=p>}</span>

<span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>Identity</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Identity</span> <span class=n>x</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>(</span><span class=n>f</span> <span class=n>x</span><span class=p>)</span>

<span class=kr>instance</span> <span class=kt>Applicative</span> <span class=kt>Identity</span> <span class=kr>where</span>
    <span class=n>pure</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=n>x</span>
    <span class=kt>Identity</span> <span class=n>f</span> <span class=o>&lt;*&gt;</span> <span class=kt>Identity</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>(</span><span class=n>f</span> <span class=n>x</span><span class=p>)</span>

<span class=c1>-- formulating</span>
<span class=nf>traverse</span> <span class=kt>Identity</span> <span class=ow>=</span> <span class=kt>Identity</span>
<span class=nf>sequenceA</span> <span class=o>.</span> <span class=n>fmap</span> <span class=kt>Identity</span> <span class=ow>=</span> <span class=kt>Identity</span>
</code></pre></div><h4 id=composition-law>Composition Law</h4><p><code>Compose</code> is used to form composition of functors, but if we compose two Applicatives, we get an Applicative as result.</p><p>As per composition law, it does not matter whether the two traversals are performed separately or if they are composed in order to walk the structure only once.</p><p>The composition law is stated in terms of the Compose functor:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>newtype</span> <span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=p>{</span> <span class=n>getCompose</span> <span class=ow>::</span> <span class=n>f</span> <span class=p>(</span><span class=n>g</span> <span class=n>a</span><span class=p>)</span> <span class=p>}</span>

<span class=kr>instance</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Functor</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span><span class=p>)</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>x</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=p>(</span><span class=n>fmap</span> <span class=p>(</span><span class=n>fmap</span> <span class=n>f</span><span class=p>)</span> <span class=n>x</span><span class=p>)</span>

<span class=kr>instance</span> <span class=p>(</span><span class=kt>Applicative</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Applicative</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>Compose</span> <span class=n>f</span> <span class=n>g</span><span class=p>)</span> <span class=kr>where</span>
    <span class=n>pure</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=p>(</span><span class=n>pure</span> <span class=p>(</span><span class=n>pure</span> <span class=n>x</span><span class=p>)</span><span class=p>)</span>
    <span class=kt>Compose</span> <span class=n>f</span> <span class=o>&lt;*&gt;</span> <span class=kt>Compose</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=p>(</span><span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>)</span> <span class=o>&lt;$&gt;</span> <span class=n>f</span> <span class=o>&lt;*&gt;</span> <span class=n>x</span><span class=p>)</span>

<span class=c1>-- formulating</span>
<span class=nf>traverse</span> <span class=p>(</span><span class=kt>Compose</span> <span class=o>.</span> <span class=n>fmap</span> <span class=n>g</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=o>.</span> <span class=n>fmap</span> <span class=p>(</span><span class=n>traverse</span> <span class=n>g</span><span class=p>)</span> <span class=o>.</span> <span class=n>traverse</span> <span class=n>f</span>
<span class=nf>sequenceA</span> <span class=o>.</span> <span class=n>fmap</span> <span class=kt>Compose</span> <span class=ow>=</span> <span class=kt>Compose</span> <span class=o>.</span> <span class=n>fmap</span> <span class=n>sequenceA</span> <span class=o>.</span> <span class=n>sequenceA</span>
</code></pre></div><h4 id=applicative-homomorphism-law>Applicative Homomorphism Law</h4><p>An applicative homomorphism is analogoues to <a href=https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms>Monoid homomorphisms</a>, and it is a function which preserves the Applicative operations, such that:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- Given a choice of f and g, and for any a,</span>
<span class=nf>t</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Applicative</span> <span class=n>f</span><span class=p>,</span> <span class=kt>Applicative</span> <span class=n>g</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>g</span> <span class=n>a</span>

<span class=nf>t</span> <span class=p>(</span><span class=n>pure</span> <span class=n>x</span><span class=p>)</span> <span class=ow>=</span> <span class=n>pure</span> <span class=n>x</span>
<span class=nf>t</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>y</span><span class=p>)</span> <span class=ow>=</span> <span class=n>t</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>t</span> <span class=n>y</span>

<span class=c1>-- formulating</span>
<span class=nf>t</span> <span class=o>.</span> <span class=n>traverse</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>traverse</span> <span class=p>(</span><span class=n>t</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>
<span class=nf>t</span> <span class=o>.</span> <span class=n>sequenceA</span> <span class=ow>=</span> <span class=n>sequenceA</span> <span class=o>.</span> <span class=n>fmap</span> <span class=n>t</span>
</code></pre></div><h2 id=implementation-for-foldable-using-traversable>Implementation for Foldable using Traversable</h2><p>Traversable allows us to define Functor and Foldable, i.e. implement both <code>fmap</code> and <code>foldMap</code> using <code>traverse</code> as long as Traversable instance follows the laws.</p><h4 id=fmap>fmap</h4><p>Comparing fmap with traverse :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>fmap</span> 	 <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span>
<span class=nf>traverse</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Traversable</span> <span class=n>t</span><span class=p>,</span> <span class=kt>Applicative</span> <span class=n>f</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>
</code></pre></div><p>In <code>traverse</code> the function that is passed returns a value wrapped in Applicative context, and the result obtained from traverse is also wrapped.</p><p>We can Identity functor to wrap the value after we apply the functor and then unwrap it at the end (using <code>runIdentity :: Identity a -> a</code>), to get the exact same type as fmap. Thus, using Idenity to make traversal out of an arbitrary function, we get :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>fmap</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>runIdentity</span> <span class=o>.</span> <span class=n>traverse</span> <span class=p>(</span><span class=kt>Identity</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>
</code></pre></div><h4 id=foldmap>foldMap</h4><p>Comparing foldMap with traverse :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>foldMap</span>  <span class=ow>::</span> <span class=p>(</span><span class=kt>Traversable</span> <span class=n>t</span><span class=p>,</span> <span class=kt>Monoid</span> <span class=n>m</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>m</span>
<span class=nf>traverse</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Traversable</span> <span class=n>t</span><span class=p>,</span> <span class=kt>Applicative</span> <span class=n>f</span><span class=p>)</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>t</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>t</span> <span class=n>b</span><span class=p>)</span>
</code></pre></div><p>We need a way to convert each element of Traversable to a Monoid. To do this, we will use <code>Const</code> from Control.Applicative.</p><p><code>Const</code> is a constant functor such that, the value of type <code>Const a b</code> holds value <code>a</code> which is unaffected by <code>fmap</code> . To define <code>foldMap</code> , <code>a</code> value would be an Applicative, such that :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>instance</span> <span class=kt>Monoid</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=kt>Applicative</span> <span class=p>(</span><span class=kt>Const</span> <span class=n>a</span><span class=p>)</span> <span class=kr>where</span>
    <span class=n>pure</span> <span class=kr>_</span> <span class=ow>=</span> <span class=kt>Const</span> <span class=n>mempty</span>
    <span class=kt>Const</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=kt>Const</span> <span class=n>y</span> <span class=ow>=</span> <span class=kt>Const</span> <span class=p>(</span><span class=n>x</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>y</span><span class=p>)</span>

<span class=c1>-- (&lt;*&gt;) combines the values in each context with mappend</span>
</code></pre></div><p>In order to make a traversal out of any <code>Monoid m => a -> m</code> function, we can define foldMap as :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>foldMap</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>getConst</span> <span class=o>.</span> <span class=n>traverse</span> <span class=p>(</span><span class=kt>Const</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>
</code></pre></div><h4 id=foldable-1>Foldable</h4><p>After defining <code>fmap</code> and <code>foldMap</code>, we can use them to define a Functor and a Foldable instance for any Traversable.</p><p>For example, let&rsquo;s take a simple list type :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- our definitions</span>

<span class=nf>fmap&#39;</span> <span class=n>f</span>    <span class=ow>=</span> <span class=n>runIdentity</span> <span class=o>.</span> <span class=n>traverse</span> <span class=p>(</span><span class=kt>Identity</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>
<span class=nf>foldMap&#39;</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>getConst</span> <span class=o>.</span> <span class=n>traverse</span> <span class=p>(</span><span class=kt>Const</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>

<span class=c1>-- defining Functor and Foldable instance for List</span>

<span class=kr>data</span> <span class=kt>List</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Nil</span>
            <span class=o>|</span> <span class=kt>Cons</span> <span class=n>a</span> <span class=p>(</span><span class=kt>List</span> <span class=n>a</span><span class=p>)</span>
            <span class=kr>deriving</span> <span class=kt>Show</span>

<span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>List</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=ow>=</span> <span class=n>fmap&#39;</span>

<span class=kr>instance</span> <span class=kt>Foldable</span> <span class=kt>List</span> <span class=kr>where</span>
    <span class=n>foldMap</span> <span class=ow>=</span> <span class=n>foldMap&#39;</span>

<span class=kr>instance</span> <span class=kt>Traversable</span> <span class=kt>List</span> <span class=kr>where</span>
    <span class=n>traverse</span> <span class=kr>_</span> <span class=kt>Nil</span> <span class=ow>=</span> <span class=n>pure</span> <span class=kt>Nil</span>
    <span class=n>traverse</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Cons</span> <span class=n>x</span> <span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=kt>Cons</span> <span class=p>(</span><span class=n>f</span> <span class=n>x</span><span class=p>)</span> <span class=o>&lt;*&gt;</span> <span class=n>traverse</span> <span class=n>f</span> <span class=n>xs</span>
</code></pre></div><p>Checking how it works on ghci :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>traverse</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=kt>Just</span> <span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span><span class=p>)</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>1</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>2</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>3</span> <span class=kt>Nil</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
<span class=kt>Just</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>2</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>3</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>4</span> <span class=kt>Nil</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>

<span class=o>&gt;</span> <span class=n>fold</span> <span class=p>(</span><span class=kt>Cons</span> <span class=s>&#34;</span><span class=s>hello</span><span class=s>&#34;</span> <span class=p>(</span><span class=kt>Cons</span> <span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span> <span class=kt>Nil</span><span class=p>)</span><span class=p>)</span>
<span class=s>&#34;</span><span class=s>hellohaskell</span><span class=s>&#34;</span>

<span class=o>&gt;</span> <span class=n>fmap</span> <span class=p>(</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>1</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>2</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>3</span> <span class=kt>Nil</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
<span class=kt>Cons</span> <span class=mi>2</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>3</span> <span class=p>(</span><span class=kt>Cons</span> <span class=mi>4</span> <span class=kt>Nil</span><span class=p>)</span><span class=p>)</span>
</code></pre></div></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/applicative-functors/>Haskell's Applicative Functors</a></li></ul></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=/about target=_blank>About</a></div><div class=site-footer-item><a href=/posts target=_blank>Posts</a></div><div class=site-footer-item><a href=https://github.com/namratachaudhary target=_blank>Github</a></div><div class=site-footer-item><a href=https://www.linkedin.com/in/namrata-c-542b8a56/ target=_blank>LinkedIn</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>