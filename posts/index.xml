<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Namc's blog</title><link>/posts/</link><description>Recent content in Posts on Namc's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Oct 2021 12:39:46 +0530</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Homemade Cookie-box 2021</title><link>/posts/cookie-box-2021/</link><pubDate>Tue, 19 Oct 2021 12:39:46 +0530</pubDate><guid>/posts/cookie-box-2021/</guid><description>Hello good people.
I usually send out a box of assorted home-made butter cookies to friends and family, but this year I am hoping to send it out to some good people here. They&amp;rsquo;re nice hand-crafted boxes and the cookies are made in a nice, clean kitchen with fresh organically sourced ingredients. I&amp;rsquo;m hoping to send out about 20-25 boxes depending on how the sign-ups go.
Cookies - Made of locally sourced ingredients, mostly organic Gluten-free options available (peanut cookies, almond cookies) I suppose butter comprises as dairy - so no dairy-free option, but peanut cookies can be made that way.</description></item><item><title>Haskell : Higher-Rank and Higher-Kinded Types</title><link>/posts/higher-rank-higher-kinded-types/</link><pubDate>Mon, 15 Jun 2020 12:20:12 +0530</pubDate><guid>/posts/higher-rank-higher-kinded-types/</guid><description>Hi! We&amp;rsquo;re gonna look at higher-rank and higher-kinded types, specifically in Haskell but I will try to cover the concept as generically as possible.
Two types of &amp;ldquo;Polymorphism&amp;rdquo; in Haskell Parametric Polymorphism Ad-hoc Polymorphism (also known as typeclass) A function is parametrically polymorphic if it behaves uniformly for all types, in at least one of its type parameters
Couple of examples could be -
a. Simple swap function</description></item><item><title>Using the right tools for an Observable Kubernetes Cluster</title><link>/posts/cloud-observability-ii/</link><pubDate>Tue, 12 May 2020 06:25:12 +0200</pubDate><guid>/posts/cloud-observability-ii/</guid><description>In the last part, we saw commonly used terms and tools in CNCF landscape for making your Cloud Infrastructure observable. In this section we will read about how we can use those concepts and handful of tools to get started.
Creating a very basic and bare-minimum observable infrastructure Considering that the system engineer is somewhat well-versed with cloud-friendly observability tools, let’s look at some tools that can help lay-down a sound foundation for system observability</description></item><item><title>Understanding Observability (and the family) in Cloud Infrastructure</title><link>/posts/cloud-observability/</link><pubDate>Mon, 11 May 2020 16:25:12 +0200</pubDate><guid>/posts/cloud-observability/</guid><description>This blog post is divided in two parts -
Understanding the terminlogies in Observability Ecosystem and corresponding tools How you can use some bare-minimum tooling to improve observability in your kubernetes cluster Terminologies in Observability Ecosystem With a huge shift towards Kubernetes and therefore, a distributed systems service architecture, we see a constant need to have solid observability practices. This ranges from application-level monitoring to OS &amp;amp; Network monitoring, as well as capturing telemetry and kubernetes events.</description></item><item><title>Retries, Timeouts and Backoff</title><link>/posts/retries-timeouts-backoff/</link><pubDate>Tue, 16 Apr 2019 14:02:18 -0700</pubDate><guid>/posts/retries-timeouts-backoff/</guid><description>Distributed systems are hard. While we learn a lot about making highly available systems, we often overlook resiliency in system design.
Sure we have heard about fault-tolerant, but what is &amp;ldquo;resilience&amp;rdquo; now? Personally, I like to define it a system&amp;rsquo;s ability to handle and eventually recover from unexpected conditions. There are several ways to go about making your systems resilient to failure, but in this post, we will focus on following</description></item><item><title>SSH Tunneling - Local, Remote &amp; Dynamic</title><link>/posts/ssh-port-forwarding/</link><pubDate>Tue, 26 Jun 2018 14:02:18 -0700</pubDate><guid>/posts/ssh-port-forwarding/</guid><description>Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.
We&amp;rsquo;re going to look at the three types of port forwarding - local, remote &amp;amp; dynamic.</description></item><item><title>Haskell Lens - Part 1</title><link>/posts/lenses-part-1/</link><pubDate>Mon, 26 Mar 2018 13:00:58 +0530</pubDate><guid>/posts/lenses-part-1/</guid><description>Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead.</description></item><item><title>What is Currying</title><link>/posts/currying/</link><pubDate>Thu, 22 Feb 2018 12:07:52 +0530</pubDate><guid>/posts/currying/</guid><description>Inspiration This post is written after I saw this tweet
Every functional programming tutorial:
&amp;gt; OK, we&amp;#39;re going to talk about currying. Currying is when you break down a function tha-
*scrolls down*
&amp;gt; const Y = f =&amp;gt; (g =&amp;gt; g(g))(g =&amp;gt; f(x =&amp;gt; g(g)(x))) pic.twitter.com/EPHH9SG5ay
&amp;mdash; Ben Howdle (@ben_howdle) February 21, 2018 And realized that we need a simpler tutorial to understand currying, the logic behind it, the nuances and the usage.</description></item><item><title>Foldable and Traversable in Haskell</title><link>/posts/foldables-traversals/</link><pubDate>Wed, 24 Jan 2018 12:07:52 +0530</pubDate><guid>/posts/foldables-traversals/</guid><description>Foldable Foldable represents data structure type class that
provides a generalisation of list folding (foldr and friends). provides operations derived from list foldings to arbitrary data structures You can use a Foldable where you would have to traverse a dataset and reduce it to a single result.
Get the product of a list Get the max path value in a tree In short, fold can be understood as function to reduce a large structure into a single result.</description></item><item><title>Haskell's Applicative Functors</title><link>/posts/applicative-functors/</link><pubDate>Fri, 12 Jan 2018 18:20:12 +0530</pubDate><guid>/posts/applicative-functors/</guid><description>Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc.</description></item><item><title>lazy-seq - Lazy Sequences in Clojure</title><link>/posts/lazy-seq/</link><pubDate>Wed, 10 Jan 2018 01:00:46 +0530</pubDate><guid>/posts/lazy-seq/</guid><description>Basic idea Evaluation of an expression is delayed until the value is needed.
There are two ways to achieve the above :
use lambda functions at runtime
use macros/special forms at compile time
With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms.</description></item><item><title>Structured Clojure: Protocols</title><link>/posts/protocols/</link><pubDate>Thu, 04 Jan 2018 10:20:20 +0530</pubDate><guid>/posts/protocols/</guid><description>Protocols in clojure are a way to define functions that operate in different ways on different types. As someone mentioned, Clojure protocols help in solving the expression problem.
Expression Problem Your program is a combination of a datatype and operations over it.
Expression problem calls for an implementation of the program such that —
new functionalities and data-structures can be added that play well with existing functionality
the above is done whilst maintaining type safety; i.</description></item><item><title>Clojure - Atoms</title><link>/posts/atoms/</link><pubDate>Tue, 26 Dec 2017 12:39:46 +0530</pubDate><guid>/posts/atoms/</guid><description>In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.</description></item></channel></rss>