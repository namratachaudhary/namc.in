<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="__namc"><meta property="og:url" content="/posts/protocols/"><link rel=canonical href=/posts/protocols/><link rel=alternate type=application/atom+xml href=/index.xml title="Namc's blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Structured Clojure: Protocols","headline":"Structured Clojure: Protocols","description":"Clojure Protocols - Definition, implementation, extension, reification","inLanguage":"en-US","author":"__namc","creator":"__namc","publisher":"__namc","accountablePerson":"__namc","copyrightHolder":"__namc","copyrightYear":"2018","datePublished":"2018-01-04 10:20:20 \x2b0530 \x2b0530","dateModified":"2018-01-04 10:20:20 \x2b0530 \x2b0530","url":"\/posts\/protocols\/","keywords":["Clojure"]}</script><title>Structured Clojure: Protocols - Namc's blog</title><meta property="og:title" content="Structured Clojure: Protocols - Namc's blog"><meta property="og:type" content="article"><meta property="og:description" content="Clojure Protocols - Definition, implementation, extension, reification"><meta name=description content="Clojure Protocols - Definition, implementation, extension, reification"><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Namc's blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Structured Clojure: Protocols</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-01-04 10:20:20 +0530">04 Jan 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://namc.in/>@__namc</a></div></div></div></header><div class="post-content markdown-body"><p>Protocols in clojure are a way to define functions that operate in different ways on different types. As someone <a href=https://stackoverflow.com/questions/4509782/simple-explanation-of-clojure-protocols#4513556>mentioned</a>, Clojure protocols help in solving the expression problem.</p><h3 id=expression-problem>Expression Problem</h3><p>Your program is a combination of a datatype and operations over it.</p><p>Expression problem calls for an implementation of the program such that —</p><ul><li><p>new functionalities and data-structures can be added that play well with existing functionality</p></li><li><p>the above is done whilst maintaining type safety; i.e. without recompiling old modules, and without casts/runtime type checks.</p></li></ul><p>For languages like Javascript or Clojure, even if you cannot statically check type-safety, you would still expect that level of consistency. Although, it is easy to add new procedures and functions, but it is relatively tougher to add new data types , esp where switch , pattern-matching (case , cond) etc are involved. You might have to modify your code to accommodate these changes.</p><p>So we make use of Protocols in Clojure (Implicits in Scala, Typeclasses in Haskell, Interface in Java) to solve the Expression Problem</p><p>—-</p><p>Rough idea of what follows
We’re going to define a bunch of protocols and geometrical shapes to demonstrate how protocols work, and are defined. Then we will try to extend and reify them.</p><p>&ndash;</p><h3 id=definition>Definition</h3><p>Since we’re talking about geometrical shapes, let’s assume they are closed, and have an area. So that becomes a protocol.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defprotocol </span>Name
        <span style=color:#e6db74>&#34;This interface states `name` method should be implemented&#34;</span>
        (name [shape] <span style=color:#e6db74>&#34;name of the shape&#34;</span>))

user&gt; (<span style=color:#66d9ef>defprotocol </span>Area
        (<span style=color:#a6e22e>area</span> [shape] <span style=color:#e6db74>&#34;calculates area&#34;</span>))
</code></pre></div><p>Now we define an immutable persistent maps, which will implement the protocol.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defrecord </span>Square [size])
user&gt; (<span style=color:#66d9ef>defrecord </span>Rectangle [a b])
</code></pre></div><h3 id=implementation>Implementation</h3><p>We have defined protocols, and records on which those protocols will be implemented. However, we need to define how those protocols shall be defined for respective records.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>extend-type</span> Square
        Name                         <span style=color:#75715e>; enforces the protocol Shape</span>
        (name [shape]                <span style=color:#75715e>; implements `name` associated</span>
          <span style=color:#e6db74>&#34;Square&#34;</span>)
        Area                         <span style=color:#75715e>; enforces the protocol Area</span>
        (<span style=color:#a6e22e>area</span> [shape]                <span style=color:#75715e>; implements `area` associated</span>
        (<span style=color:#a6e22e>Math/pow</span> (<span style=color:#e6db74>:side</span> shape) <span style=color:#ae81ff>2</span>)))
</code></pre></div><p>Let’s extend the protocols to other record.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>extend-type</span> Rectangle
        Name
        (name [shape]
          <span style=color:#e6db74>&#34;Rectangle&#34;</span>)
        Area
        (<span style=color:#a6e22e>area</span> [shape]
        (* (<span style=color:#e6db74>:a</span> shape) (<span style=color:#e6db74>:b</span> shape))))
</code></pre></div><p>As you can see, we are not trying to change the values of the <code>map</code> . In fact we are using the existing properties to define how the protocol should be implemented, since <code>area</code> and <code>shape</code> differs for each record.</p><h3 id=extension>Extension</h3><p>The purpose of extending a protocol is to provide several implementations of the same protocol all at once. A protocol can be extended using another protocol.</p><p>Let’s define another protocol for the <code>shapes</code>, but there is a constraint. We need to extend the protocol such that this new protocol does not alter the existing code. Anyway we cannot change the definition of <code>defrecords</code> (they’re immutable).</p><p>So is this possible? Yes. Let’s define another property for the shape, <code>Perimeter</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defprotocol </span>Perimeter
        <span style=color:#e6db74>&#34;Returns the perimeter of the shape&#34;</span>
        (<span style=color:#a6e22e>perimeter</span> [shape] <span style=color:#e6db74>&#34;perimeter of the shape&#34;</span>))

user&gt; (<span style=color:#a6e22e>extend-protocol</span> Perimeter
        Square
          (<span style=color:#a6e22e>perimeter</span> [shape] (* (<span style=color:#e6db74>:side</span> shape) <span style=color:#ae81ff>4</span>))
        Rectangle
          (<span style=color:#a6e22e>perimeter</span> [shape] (* (+ (<span style=color:#e6db74>:a</span> shape) (<span style=color:#e6db74>:b</span> shape)) <span style=color:#ae81ff>2</span>)))
</code></pre></div><p>Great!</p><p>But what if we have a new shape?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defrecord </span>Triangle [a b c])
</code></pre></div><p>Can we extend our protocols to the new record without changing the existing code? Sure, let’s try — </p><p>(FYI we did this above)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>extend-type</span> Triangle
        Name
        (name [shape]
          <span style=color:#e6db74>&#34;Triangle&#34;</span>)
        Area
        (<span style=color:#a6e22e>area</span> [{<span style=color:#e6db74>:keys</span> [a b c]}]                <span style=color:#75715e>; this can be sketchy</span>
        (<span style=color:#66d9ef>let </span>[s (/ (+ a b c)) <span style=color:#ae81ff>2</span>]               <span style=color:#75715e>; Heron&#39;s formula</span>
          (<span style=color:#a6e22e>Math/sqrt</span> (* s (- s a) (- s b) (- s c))))))
</code></pre></div><h3 id=reification>Reification</h3><p>reify is for the case where you want to create an anonymous implementation of a protocol, which is useful for taking advantage of local context e.g. creating local overrides.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#75715e>;;; &#39;reduce-unit-area&#39; is the function returing a &#39;reify&#39; of area.</span>
<span style=color:#75715e>;;; This is when someone computes an area, the area of some shapes</span>
<span style=color:#75715e>;;; is reduced by 1 unit.</span>
user&gt; (<span style=color:#66d9ef>defn </span>reduce-unit-area []
        (<span style=color:#a6e22e>reify</span> Area
          (<span style=color:#a6e22e>area</span> [_]
            (- <span style=color:#ae81ff>1</span> (<span style=color:#a6e22e>area</span> shape)))))
</code></pre></div><p>You can try this code in REPL and see the results for yourself.</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/atoms/>Clojure - Atoms</a></li></ul></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=/about target=_blank>About</a></div><div class=site-footer-item><a href=https://github.com/namratachaudhary target=_blank>Github</a></div><div class=site-footer-item><a href=https://www.linkedin.com/in/namrata-c-542b8a56/ target=_blank>LinkedIn</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>