<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="/posts/protocols/"><link rel=canonical href=/posts/protocols/><link rel=alternate type=application/atom+xml href=/index.xml><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Structured Clojure: Protocols","headline":"Structured Clojure: Protocols","description":"Clojure Protocols - Definition, implementation, extension, reification","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2018","datePublished":"2018-01-04 10:20:20 \x2b0530 \x2b0530","dateModified":"2018-01-04 10:20:20 \x2b0530 \x2b0530","url":"\/posts\/protocols\/","keywords":["Clojure"]}</script><title>Structured Clojure: Protocols -</title><meta property="og:title" content="Structured Clojure: Protocols -"><meta property="og:type" content="article"><meta property="og:description" content="Clojure Protocols - Definition, implementation, extension, reification"><meta name=description content="Clojure Protocols - Definition, implementation, extension, reification"><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Structured Clojure: Protocols</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-01-04 10:20:20 +0530">04 Jan 2018</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>Protocols in clojure are a way to define functions that operate in different ways on different types. As someone <a href=https://stackoverflow.com/questions/4509782/simple-explanation-of-clojure-protocols#4513556>mentioned</a>, Clojure protocols help in solving the expression problem.</p><h3 id=expression-problem>Expression Problem</h3><p>Your program is a combination of a datatype and operations over it.</p><p>Expression problem calls for an implementation of the program such that —</p><ul><li><p>new functionalities and data-structures can be added that play well with existing functionality</p></li><li><p>the above is done whilst maintaining type safety; i.e. without recompiling old modules, and without casts/runtime type checks.</p></li></ul><p>For languages like Javascript or Clojure, even if you cannot statically check type-safety, you would still expect that level of consistency. Although, it is easy to add new procedures and functions, but it is relatively tougher to add new data types , esp where switch , pattern-matching (case , cond) etc are involved. You might have to modify your code to accommodate these changes.</p><p>So we make use of Protocols in Clojure (Implicits in Scala, Typeclasses in Haskell, Interface in Java) to solve the Expression Problem</p><p>—-</p><p>Rough idea of what follows
We’re going to define a bunch of protocols and geometrical shapes to demonstrate how protocols work, and are defined. Then we will try to extend and reify them.</p><p>&ndash;</p><h3 id=definition>Definition</h3><p>Since we’re talking about geometrical shapes, let’s assume they are closed, and have an area. So that becomes a protocol.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defprotocol </span><span class=nv>Name</span>
        <span class=s>&#34;This interface states `name` method should be implemented&#34;</span>
        <span class=p>(</span><span class=nb>name </span><span class=p>[</span><span class=nv>shape</span><span class=p>]</span> <span class=s>&#34;name of the shape&#34;</span><span class=p>)</span><span class=p>)</span>

<span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defprotocol </span><span class=nv>Area</span>
        <span class=p>(</span><span class=nf>area</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span> <span class=s>&#34;calculates area&#34;</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>Now we define an immutable persistent maps, which will implement the protocol.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defrecord </span><span class=nv>Square</span> <span class=p>[</span><span class=nv>size</span><span class=p>]</span><span class=p>)</span>
<span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defrecord </span><span class=nv>Rectangle</span> <span class=p>[</span><span class=nv>a</span> <span class=nv>b</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><h3 id=implementation>Implementation</h3><p>We have defined protocols, and records on which those protocols will be implemented. However, we need to define how those protocols shall be defined for respective records.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>extend-type</span> <span class=nv>Square</span>
        <span class=nv>Name</span>                         <span class=c1>; enforces the protocol Shape</span>
        <span class=p>(</span><span class=nb>name </span><span class=p>[</span><span class=nv>shape</span><span class=p>]</span>                <span class=c1>; implements `name` associated</span>
          <span class=s>&#34;Square&#34;</span><span class=p>)</span>
        <span class=nv>Area</span>                         <span class=c1>; enforces the protocol Area</span>
        <span class=p>(</span><span class=nf>area</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span>                <span class=c1>; implements `area` associated</span>
        <span class=p>(</span><span class=nf>Math/pow</span> <span class=p>(</span><span class=ss>:side</span> <span class=nv>shape</span><span class=p>)</span> <span class=mi>2</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>Let’s extend the protocols to other record.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>extend-type</span> <span class=nv>Rectangle</span>
        <span class=nv>Name</span>
        <span class=p>(</span><span class=nb>name </span><span class=p>[</span><span class=nv>shape</span><span class=p>]</span>
          <span class=s>&#34;Rectangle&#34;</span><span class=p>)</span>
        <span class=nv>Area</span>
        <span class=p>(</span><span class=nf>area</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span>
        <span class=p>(</span><span class=nb>* </span><span class=p>(</span><span class=ss>:a</span> <span class=nv>shape</span><span class=p>)</span> <span class=p>(</span><span class=ss>:b</span> <span class=nv>shape</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>As you can see, we are not trying to change the values of the <code>map</code> . In fact we are using the existing properties to define how the protocol should be implemented, since <code>area</code> and <code>shape</code> differs for each record.</p><h3 id=extension>Extension</h3><p>The purpose of extending a protocol is to provide several implementations of the same protocol all at once. A protocol can be extended using another protocol.</p><p>Let’s define another protocol for the <code>shapes</code>, but there is a constraint. We need to extend the protocol such that this new protocol does not alter the existing code. Anyway we cannot change the definition of <code>defrecords</code> (they’re immutable).</p><p>So is this possible? Yes. Let’s define another property for the shape, <code>Perimeter</code>.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defprotocol </span><span class=nv>Perimeter</span>
        <span class=s>&#34;Returns the perimeter of the shape&#34;</span>
        <span class=p>(</span><span class=nf>perimeter</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span> <span class=s>&#34;perimeter of the shape&#34;</span><span class=p>)</span><span class=p>)</span>

<span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>extend-protocol</span> <span class=nv>Perimeter</span>
        <span class=nv>Square</span>
          <span class=p>(</span><span class=nf>perimeter</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span> <span class=p>(</span><span class=nb>* </span><span class=p>(</span><span class=ss>:side</span> <span class=nv>shape</span><span class=p>)</span> <span class=mi>4</span><span class=p>)</span><span class=p>)</span>
        <span class=nv>Rectangle</span>
          <span class=p>(</span><span class=nf>perimeter</span> <span class=p>[</span><span class=nv>shape</span><span class=p>]</span> <span class=p>(</span><span class=nb>* </span><span class=p>(</span><span class=nb>+ </span><span class=p>(</span><span class=ss>:a</span> <span class=nv>shape</span><span class=p>)</span> <span class=p>(</span><span class=ss>:b</span> <span class=nv>shape</span><span class=p>)</span><span class=p>)</span> <span class=mi>2</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>Great!</p><p>But what if we have a new shape?</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defrecord </span><span class=nv>Triangle</span> <span class=p>[</span><span class=nv>a</span> <span class=nv>b</span> <span class=nv>c</span><span class=p>]</span><span class=p>)</span>
</code></pre></div><p>Can we extend our protocols to the new record without changing the existing code? Sure, let’s try — </p><p>(FYI we did this above)</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>extend-type</span> <span class=nv>Triangle</span>
        <span class=nv>Name</span>
        <span class=p>(</span><span class=nb>name </span><span class=p>[</span><span class=nv>shape</span><span class=p>]</span>
          <span class=s>&#34;Triangle&#34;</span><span class=p>)</span>
        <span class=nv>Area</span>
        <span class=p>(</span><span class=nf>area</span> <span class=p>[</span><span class=p>{</span><span class=ss>:keys</span> <span class=p>[</span><span class=nv>a</span> <span class=nv>b</span> <span class=nv>c</span><span class=p>]</span><span class=p>}</span><span class=p>]</span>                <span class=c1>; this can be sketchy</span>
        <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>s</span> <span class=p>(</span><span class=nb>/ </span><span class=p>(</span><span class=nb>+ </span><span class=nv>a</span> <span class=nv>b</span> <span class=nv>c</span><span class=p>)</span><span class=p>)</span> <span class=mi>2</span><span class=p>]</span>               <span class=c1>; Heron&#39;s formula</span>
          <span class=p>(</span><span class=nf>Math/sqrt</span> <span class=p>(</span><span class=nb>* </span><span class=nv>s</span> <span class=p>(</span><span class=nb>- </span><span class=nv>s</span> <span class=nv>a</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>s</span> <span class=nv>b</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>s</span> <span class=nv>c</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><h3 id=reification>Reification</h3><p>reify is for the case where you want to create an anonymous implementation of a protocol, which is useful for taking advantage of local context e.g. creating local overrides.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=c1>;;; &#39;reduce-unit-area&#39; is the function returing a &#39;reify&#39; of area.</span>
<span class=c1>;;; This is when someone computes an area, the area of some shapes</span>
<span class=c1>;;; is reduced by 1 unit.</span>
<span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defn </span><span class=nv>reduce-unit-area</span> <span class=p>[</span><span class=p>]</span>
        <span class=p>(</span><span class=nf>reify</span> <span class=nv>Area</span>
          <span class=p>(</span><span class=nf>area</span> <span class=p>[</span><span class=nv>_</span><span class=p>]</span>
            <span class=p>(</span><span class=nb>- </span><span class=mi>1</span> <span class=p>(</span><span class=nf>area</span> <span class=nv>shape</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>You can try this code in REPL and see the results for yourself.</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/atoms/>Clojure - Atoms</a></li></ul></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>