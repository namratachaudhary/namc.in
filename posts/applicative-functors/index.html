<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="__namc"><meta property="og:url" content="/posts/applicative-functors/"><link rel=canonical href=/posts/applicative-functors/><link rel=alternate type=application/atom+xml href=/index.xml title="Namc's blog - Tech, Food, Skincare"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Haskell\x27s Applicative Functors","headline":"Haskell\x27s Applicative Functors","description":"Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.\nFunctor According to Haskell docs, a functor is simply something that can be mapped over.\nIn other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc.","inLanguage":"en-US","author":"__namc","creator":"__namc","publisher":"__namc","accountablePerson":"__namc","copyrightHolder":"__namc","copyrightYear":"2018","datePublished":"2018-01-12 18:20:12 \x2b0530 \x2b0530","dateModified":"2018-01-12 18:20:12 \x2b0530 \x2b0530","url":"\/posts\/applicative-functors\/","keywords":["Haskell"]}</script><title>Haskell's Applicative Functors - Namc's blog - Tech, Food, Skincare</title><meta property="og:title" content="Haskell's Applicative Functors - Namc's blog - Tech, Food, Skincare"><meta property="og:type" content="article"><meta property="og:description" content="Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc."><meta name=description content="Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Namc's blog - Tech, Food, Skincare"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Haskell's Applicative Functors</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-01-12 18:20:12 +0530">12 Jan 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://namc.in/>@__namc</a></div></div></div></header><div class="post-content markdown-body"><p>Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.</p><h3 id=functor>Functor</h3><p>According to <a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html>Haskell docs</a>, a functor is simply something that can be mapped over.</p><p>In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc. E.g.; a list or sequence is a container of homogenous elements. You can apply a function to each of the elements, which produces a new sequence of elements transformed by the function.</p><p>Let’s create a new functor, implementing <code>myfmap</code> such that <code>Data.Map</code> is an instance of the new functor typeclass. <code>myfmap</code> applies a function <code>f</code> to the value(s) inside functor’s context while preserving the context.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>import</span> Data.Map <span style=color:#66d9ef>as</span> DataMap
<span style=color:#66d9ef>import</span> Data.List <span style=color:#66d9ef>as</span> DataList

<span style=color:#66d9ef>class</span> <span style=color:#66d9ef>MyFunctor</span> f <span style=color:#66d9ef>where</span>
  myfmap <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b

<span style=color:#66d9ef>instance</span> (<span style=color:#66d9ef>Ord</span> k) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>MyFunctor</span> (<span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span><span style=color:#66d9ef>Map</span> k) <span style=color:#66d9ef>where</span>
  myfmap f x <span style=color:#f92672>=</span> <span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span>fromList <span style=color:#f92672>$</span>
                     <span style=color:#66d9ef>DataList</span><span style=color:#f92672>.</span>map (<span style=color:#a6e22e>\</span>(p,q) <span style=color:#f92672>-&gt;</span>(p,f q)) <span style=color:#f92672>$</span>
                     <span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span>toList x
</code></pre></div><h3 id=applicative-functor>Applicative Functor</h3><p>In computer science, applicative is an abstraction for a context, and it has the ability to apply functions in the same type of context to all elements in the context. For example, a sequence A which has homogenous elements, and sequence B which consists of functions that can be applied to sequence A , which produce a new sequence of elements transformed by all the functions. (Super confusing? Sorry 😕 . We will clear it up)</p><p>The Applicative typeclass in Haskell is located in Control.Applicative module and defines pure and <code>(&lt;*>)</code> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Functor</span> f) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#66d9ef>where</span>
    pure <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> f a
    (<span style=color:#f92672>&lt;*&gt;</span>) <span style=color:#66d9ef>:</span> f (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b
</code></pre></div><ul><li><p>An Applicative has to be Functor. This is a class constraint.</p></li><li><p><code>pure</code> takes any context and returns an Applicative the value of context inside it.</p></li><li><p><code>&lt;*></code> is a representation of <code>fmap</code> , where <code>&lt;*></code> takes a functor that has a function in it and another functor and run the function from first functor and maps it over the second functor. Whereas <code>fmap</code> which takes a function and functor and applies the function inside the functor.</p></li></ul><p>—-</p><h3 id=list-an-an-applicative>List an an Applicative!</h3><p>List also instantiates an applicative typeclass, with implementation as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    pure x <span style=color:#f92672>=</span> [x]
    fs <span style=color:#f92672>&lt;*&gt;</span> xs <span style=color:#f92672>=</span> [f x <span style=color:#f92672>|</span> f <span style=color:#f92672>&lt;-</span> fs, x <span style=color:#f92672>&lt;-</span> xs]
</code></pre></div><p>Here, the implementation of <code>(&lt;*>)</code> is basically a list comprehension, where every function is applied to every value. For example :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ghci&gt; <span style=color:#f92672>(</span>*<span style=color:#f92672>)</span> &lt;$&gt; <span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span> &lt;*&gt; <span style=color:#f92672>[</span>4, 5<span style=color:#f92672>]</span>
<span style=color:#f92672>[</span>8, 10, 12, 15<span style=color:#f92672>]</span>
</code></pre></div><p>If you want to apply each function in first list to the respective value in second list, the <a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html#t:ZipList>ZipList typeclass</a> is very handy.</p><p>&ndash;</p><h3 id=curious-case-of-eitherhttpshackagehaskellorgpackagebase-41000docsdata-eitherhtml>Curious case of <a href=https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Either.html>Either</a></h3><p>The base <strong>Monad</strong> instance for <code>Either</code> is defined as follows.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Monad</span> (<span style=color:#66d9ef>Either</span> e) <span style=color:#66d9ef>where</span>
  return <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span>
  <span style=color:#66d9ef>Left</span> e  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
  <span style=color:#66d9ef>Right</span> a <span style=color:#f92672>&gt;&gt;=</span> f <span style=color:#f92672>=</span> f a
</code></pre></div><p>This instance has inherent short-circuiting. But in case you would like to collect error messages which occur anywhere in the above computation, it goes against <code>(>>=)</code> and <code>lazy-evaluation/short-circuiting</code> .</p><ul><li><p>Lazy evaluation is when we proceed from left to right, when a single computation “fails” into the Left then all the rest do as well.</p></li><li><p><code>(>>=)</code> takes a function, maps it over an instance of a monad and then flattens the result.</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m a <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> m b) <span style=color:#f92672>-&gt;</span> m b
</code></pre></div><ul><li><code>(>>=)</code> produces <code>m b</code> from <code>m a</code> so long as it can run <code>(a -> m b)</code> . This demands that the value of a should ideally exists during the time of computation, and this is impossible for <code>Either</code> .</li></ul><p>So let’s try to solve the above problem by defining a <strong>Functor</strong> instance of Either .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> (<span style=color:#66d9ef>Either</span> a) <span style=color:#66d9ef>where</span>
    fmap f (<span style=color:#66d9ef>Left</span> x) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> x
    fmap f (<span style=color:#66d9ef>Right</span> y) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span> (f y)
</code></pre></div><p>Things we can understand from the above definition :</p><ul><li><p>We know the definition of <code>fmap :: (c -> d) -> f c -> f d</code> .</p></li><li><p>If we replace <code>f</code> with <code>Either a</code> , we get <code>fmap :: (c -> d) -> Either a c -> Either a d</code></p></li><li><p>The problem with this implementation of <code>Either</code> is that we cannot map over Left .</p></li></ul><p>😱 Why?
To understand that, let <code>Either a b</code> computation, which may succeed and return b or fail with error a , similar to monad instance. So the functor instance does not map over <code>Left</code> values since you would want to map over the computation, if it fails, there is nothing to manipulate.</p><h3 id=implementing-an-applicative-instance>Implementing an Applicative instance</h3><p>Applicative Monad instance cannot have a corresponding <code>Monad</code>.</p><p>As we saw the definition of Applicative, we will define pure and <code>(&lt;*>)</code> . Defining <code>pure</code> is rather simple, as we want it return the Right element. Implementation of <code>(&lt;*>)</code> is little tricky . The following cases need to be considered for defining <code>(&lt;*>)</code> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> (<span style=color:#66d9ef>Either</span> e) <span style=color:#66d9ef>where</span>
    pure                 <span style=color:#f92672>=</span>  <span style=color:#66d9ef>Right</span>
    <span style=color:#66d9ef>Right</span> f <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Right</span> a  <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span> (f a)
    <span style=color:#66d9ef>Left</span>  e  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Right</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
    <span style=color:#66d9ef>Right</span> <span style=color:#66d9ef>_</span>  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Left</span>  e <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
    <span style=color:#66d9ef>Left</span> e1  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Left</span> e2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> (e1 <span style=color:#f92672>&lt;&gt;</span> e2)
</code></pre></div><ul><li><p>The first statement is the pure statement.</p></li><li><p><code>(&lt;*>)</code> allows evaluation in parallel instead of necessarily needing results from previous computation to compute present values.</p></li><li><p>Thus, we can use our purely <code>Applicative Either</code> to collect errors, ignoring Right if any Left exist in the sequence.</p></li><li><p>As soon as it hits a Left, it aborts and returns that Left.</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span> &lt;$&gt; Left <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; undefined
Left <span style=color:#e6db74>&#34;Hello&#34;</span>                              -- not undefined

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span> &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; undefined
*** Exception: Prelude.undefined          -- undefined

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span>  &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; Left <span style=color:#e6db74>&#34; World&#34;</span>
Left <span style=color:#e6db74>&#34; World&#34;</span>

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span>  &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; Right <span style=color:#e6db74>&#34; World&#34;</span>
Right <span style=color:#e6db74>&#34;Hello World&#34;</span>
</code></pre></div><h3 id=limitations>Limitations</h3><p>There’s some limitations to using purely applicative functor. As we saw in the definition of <code>(>>=) :: m a -> (a -> m b) -> m b</code> ; which means that without <code>(>>=)</code> you can’t pick “what to do next based on what came before”.</p><p>Also, if you take a generally pure function and feed the applicative arguments to it, like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; f :: a -&gt; b -&gt; c
&gt; f &lt;$&gt; getLine &lt;*&gt; getProcessID <span style=color:#e6db74>&#34;chrome&#34;</span> &lt;*&gt; getFreeMemory
</code></pre></div><p>All the arguments will get evaluated, no matter what. That is, you cannot express — “if the second argument exits, abort the rest of the computation”. Due to this, anything recursive, as well as most interactive programs do not use Applicatives. Monads, on the other hand are a good choice in that case.</p><p>&ndash;</p><p>More Reading :</p><p><a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids>LearnYouAHaskell - Functors, Applicative Functors and Monads</a></p><p><a href=http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>Adit.io - Functors, Applicative Functors and Monads in pictures</a></p><p><a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html>Hackage - Control Applicative</a></p><p><a href=https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative>StackOverfow - Monad vs Applicative</a></p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div><div class=site-footer-item><a href=https://namc.in target=_blank>About</a></div><div class=site-footer-item><a href=https://github.com/namratachaudhary target=_blank>Github</a></div><div class=site-footer-item><a href=https://www.linkedin.com/in/namrata-c-542b8a56/ target=_blank>LinkedIn</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>