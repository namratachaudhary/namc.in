<!doctype html><html lang=en><head><title>Haskell's Applicative Functors :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc."><meta name=keywords content="applicative functors,functors,monads,haskell"><meta name=robots content="noodp"><link rel=canonical href=/posts/applicative-functors/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Haskell's Applicative Functors :: __namc —"><meta name=twitter:description content="Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Haskell's Applicative Functors :: __namc —"><meta property="og:description" content="Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.
Functor According to Haskell docs, a functor is simply something that can be mapped over.
In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc."><meta property="og:url" content="/posts/applicative-functors/"><meta property="og:site_name" content="Haskell's Applicative Functors"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-01-12 18:20:12 +0530 +0530"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/applicative-functors/>Haskell&rsquo;s Applicative Functors</a></h1><div class=post-meta><span class=post-date>January 12, 2018</span></div><span class=post-tags>#<a href=/tags/haskell/>Haskell</a>&nbsp;</span><div class=post-content><div><p>Understanding Applicative functors would require some understanding about Functors and Monads. We shall try to look at brief definitions for the scope of this article.</p><h3 id=functor>Functor<a href=#functor class=hanchor arialabel=Anchor>&#8983;</a></h3><p>According to <a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html>Haskell docs</a>, a functor is simply something that can be mapped over.</p><p>In other words, it is an abstraction for a context with the ability to apply a function to all the things inside the context. The context can be defined as container, computation etc. E.g.; a list or sequence is a container of homogenous elements. You can apply a function to each of the elements, which produces a new sequence of elements transformed by the function.</p><p>Let’s create a new functor, implementing <code>myfmap</code> such that <code>Data.Map</code> is an instance of the new functor typeclass. <code>myfmap</code> applies a function <code>f</code> to the value(s) inside functor’s context while preserving the context.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>import</span> Data.Map <span style=color:#66d9ef>as</span> DataMap
<span style=color:#66d9ef>import</span> Data.List <span style=color:#66d9ef>as</span> DataList

<span style=color:#66d9ef>class</span> <span style=color:#66d9ef>MyFunctor</span> f <span style=color:#66d9ef>where</span>
  myfmap <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b

<span style=color:#66d9ef>instance</span> (<span style=color:#66d9ef>Ord</span> k) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>MyFunctor</span> (<span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span><span style=color:#66d9ef>Map</span> k) <span style=color:#66d9ef>where</span>
  myfmap f x <span style=color:#f92672>=</span> <span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span>fromList <span style=color:#f92672>$</span>
                     <span style=color:#66d9ef>DataList</span><span style=color:#f92672>.</span>map (<span style=color:#a6e22e>\</span>(p,q) <span style=color:#f92672>-&gt;</span>(p,f q)) <span style=color:#f92672>$</span>
                     <span style=color:#66d9ef>DataMap</span><span style=color:#f92672>.</span>toList x
</code></pre></div><h3 id=applicative-functor>Applicative Functor<a href=#applicative-functor class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In computer science, applicative is an abstraction for a context, and it has the ability to apply functions in the same type of context to all elements in the context. For example, a sequence A which has homogenous elements, and sequence B which consists of functions that can be applied to sequence A , which produce a new sequence of elements transformed by all the functions. (Super confusing? Sorry 😕 . We will clear it up)</p><p>The Applicative typeclass in Haskell is located in Control.Applicative module and defines pure and <code>(&lt;*>)</code> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>class</span> (<span style=color:#66d9ef>Functor</span> f) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Applicative</span> f <span style=color:#66d9ef>where</span>
    pure <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> f a
    (<span style=color:#f92672>&lt;*&gt;</span>) <span style=color:#66d9ef>:</span> f (a <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> f a <span style=color:#f92672>-&gt;</span> f b
</code></pre></div><ul><li><p>An Applicative has to be Functor. This is a class constraint.</p></li><li><p><code>pure</code> takes any context and returns an Applicative the value of context inside it.</p></li><li><p><code>&lt;*></code> is a representation of <code>fmap</code> , where <code>&lt;*></code> takes a functor that has a function in it and another functor and run the function from first functor and maps it over the second functor. Whereas <code>fmap</code> which takes a function and functor and applies the function inside the functor.</p></li></ul><p>—-</p><h3 id=list-an-an-applicative>List an an Applicative!<a href=#list-an-an-applicative class=hanchor arialabel=Anchor>&#8983;</a></h3><p>List also instantiates an applicative typeclass, with implementation as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> <span style=color:#66d9ef>[]</span> <span style=color:#66d9ef>where</span>
    pure x <span style=color:#f92672>=</span> [x]
    fs <span style=color:#f92672>&lt;*&gt;</span> xs <span style=color:#f92672>=</span> [f x <span style=color:#f92672>|</span> f <span style=color:#f92672>&lt;-</span> fs, x <span style=color:#f92672>&lt;-</span> xs]
</code></pre></div><p>Here, the implementation of <code>(&lt;*>)</code> is basically a list comprehension, where every function is applied to every value. For example :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ghci&gt; <span style=color:#f92672>(</span>*<span style=color:#f92672>)</span> &lt;$&gt; <span style=color:#f92672>[</span>2, 3<span style=color:#f92672>]</span> &lt;*&gt; <span style=color:#f92672>[</span>4, 5<span style=color:#f92672>]</span>
<span style=color:#f92672>[</span>8, 10, 12, 15<span style=color:#f92672>]</span>
</code></pre></div><p>If you want to apply each function in first list to the respective value in second list, the <a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html#t:ZipList>ZipList typeclass</a> is very handy.</p><p>&ndash;</p><h3 id=curious-case-of-eitherhttpshackagehaskellorgpackagebase-41000docsdata-eitherhtml>Curious case of <a href=https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Either.html>Either</a><a href=#curious-case-of-eitherhttpshackagehaskellorgpackagebase-41000docsdata-eitherhtml class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The base <strong>Monad</strong> instance for <code>Either</code> is defined as follows.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Monad</span> (<span style=color:#66d9ef>Either</span> e) <span style=color:#66d9ef>where</span>
  return <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span>
  <span style=color:#66d9ef>Left</span> e  <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
  <span style=color:#66d9ef>Right</span> a <span style=color:#f92672>&gt;&gt;=</span> f <span style=color:#f92672>=</span> f a
</code></pre></div><p>This instance has inherent short-circuiting. But in case you would like to collect error messages which occur anywhere in the above computation, it goes against <code>(>>=)</code> and <code>lazy-evaluation/short-circuiting</code> .</p><ul><li><p>Lazy evaluation is when we proceed from left to right, when a single computation “fails” into the Left then all the rest do as well.</p></li><li><p><code>(>>=)</code> takes a function, maps it over an instance of a monad and then flattens the result.</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m a <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> m b) <span style=color:#f92672>-&gt;</span> m b
</code></pre></div><ul><li><code>(>>=)</code> produces <code>m b</code> from <code>m a</code> so long as it can run <code>(a -> m b)</code> . This demands that the value of a should ideally exists during the time of computation, and this is impossible for <code>Either</code> .</li></ul><p>So let’s try to solve the above problem by defining a <strong>Functor</strong> instance of Either .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> (<span style=color:#66d9ef>Either</span> a) <span style=color:#66d9ef>where</span>
    fmap f (<span style=color:#66d9ef>Left</span> x) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> x
    fmap f (<span style=color:#66d9ef>Right</span> y) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span> (f y)
</code></pre></div><p>Things we can understand from the above definition :</p><ul><li><p>We know the definition of <code>fmap :: (c -> d) -> f c -> f d</code> .</p></li><li><p>If we replace <code>f</code> with <code>Either a</code> , we get <code>fmap :: (c -> d) -> Either a c -> Either a d</code></p></li><li><p>The problem with this implementation of <code>Either</code> is that we cannot map over Left .</p></li></ul><p>😱 Why?
To understand that, let <code>Either a b</code> computation, which may succeed and return b or fail with error a , similar to monad instance. So the functor instance does not map over <code>Left</code> values since you would want to map over the computation, if it fails, there is nothing to manipulate.</p><h3 id=implementing-an-applicative-instance>Implementing an Applicative instance<a href=#implementing-an-applicative-instance class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Applicative Monad instance cannot have a corresponding <code>Monad</code>.</p><p>As we saw the definition of Applicative, we will define pure and <code>(&lt;*>)</code> . Defining <code>pure</code> is rather simple, as we want it return the Right element. Implementation of <code>(&lt;*>)</code> is little tricky . The following cases need to be considered for defining <code>(&lt;*>)</code> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Applicative</span> (<span style=color:#66d9ef>Either</span> e) <span style=color:#66d9ef>where</span>
    pure                 <span style=color:#f92672>=</span>  <span style=color:#66d9ef>Right</span>
    <span style=color:#66d9ef>Right</span> f <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Right</span> a  <span style=color:#f92672>=</span> <span style=color:#66d9ef>Right</span> (f a)
    <span style=color:#66d9ef>Left</span>  e  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Right</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
    <span style=color:#66d9ef>Right</span> <span style=color:#66d9ef>_</span>  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Left</span>  e <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> e
    <span style=color:#66d9ef>Left</span> e1  <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#66d9ef>Left</span> e2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>Left</span> (e1 <span style=color:#f92672>&lt;&gt;</span> e2)
</code></pre></div><ul><li><p>The first statement is the pure statement.</p></li><li><p><code>(&lt;*>)</code> allows evaluation in parallel instead of necessarily needing results from previous computation to compute present values.</p></li><li><p>Thus, we can use our purely <code>Applicative Either</code> to collect errors, ignoring Right if any Left exist in the sequence.</p></li><li><p>As soon as it hits a Left, it aborts and returns that Left.</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span> &lt;$&gt; Left <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; undefined
Left <span style=color:#e6db74>&#34;Hello&#34;</span>                              -- not undefined

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span> &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; undefined
*** Exception: Prelude.undefined          -- undefined

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span>  &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; Left <span style=color:#e6db74>&#34; World&#34;</span>
Left <span style=color:#e6db74>&#34; World&#34;</span>

ghci&gt; <span style=color:#f92672>(</span>++<span style=color:#f92672>)</span>  &lt;$&gt; Right <span style=color:#e6db74>&#34;Hello&#34;</span> &lt;*&gt; Right <span style=color:#e6db74>&#34; World&#34;</span>
Right <span style=color:#e6db74>&#34;Hello World&#34;</span>
</code></pre></div><h3 id=limitations>Limitations<a href=#limitations class=hanchor arialabel=Anchor>&#8983;</a></h3><p>There’s some limitations to using purely applicative functor. As we saw in the definition of <code>(>>=) :: m a -> (a -> m b) -> m b</code> ; which means that without <code>(>>=)</code> you can’t pick “what to do next based on what came before”.</p><p>Also, if you take a generally pure function and feed the applicative arguments to it, like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; f :: a -&gt; b -&gt; c
&gt; f &lt;$&gt; getLine &lt;*&gt; getProcessID <span style=color:#e6db74>&#34;chrome&#34;</span> &lt;*&gt; getFreeMemory
</code></pre></div><p>All the arguments will get evaluated, no matter what. That is, you cannot express — “if the second argument exits, abort the rest of the computation”. Due to this, anything recursive, as well as most interactive programs do not use Applicatives. Monads, on the other hand are a good choice in that case.</p><p>&ndash;</p><p>More Reading :</p><p><a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids>LearnYouAHaskell - Functors, Applicative Functors and Monads</a></p><p><a href=http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>Adit.io - Functors, Applicative Functors and Monads in pictures</a></p><p><a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html>Hackage - Control Applicative</a></p><p><a href=https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative>StackOverfow - Monad vs Applicative</a></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/foldables-traversals/><span class=button__icon>←</span>
<span class=button__text>Foldable and Traversable in Haskell</span></a></span>
<span class="button next"><a href=/posts/lazy-seq/><span class=button__text>lazy-seq - Lazy Sequences in Clojure</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by panr</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>