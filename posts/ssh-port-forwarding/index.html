<!doctype html><html lang=en><head><title>SSH Tunneling - Local, Remote & Dynamic :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.
We&amp;rsquo;re going to look at the three types of port forwarding - local, remote &amp;amp; dynamic."><meta name=keywords content="networking,ssh"><meta name=robots content="noodp"><link rel=canonical href=/posts/ssh-port-forwarding/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="SSH Tunneling - Local, Remote & Dynamic :: __namc —"><meta name=twitter:description content="Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.
We&amp;rsquo;re going to look at the three types of port forwarding - local, remote &amp;amp; dynamic."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="SSH Tunneling - Local, Remote & Dynamic :: __namc —"><meta property="og:description" content="Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.
We&amp;rsquo;re going to look at the three types of port forwarding - local, remote &amp;amp; dynamic."><meta property="og:url" content="/posts/ssh-port-forwarding/"><meta property="og:site_name" content="SSH Tunneling - Local, Remote & Dynamic"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-06-26 14:02:18 -0700 -0700"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/ssh-port-forwarding/>SSH Tunneling - Local, Remote & Dynamic</a></h1><div class=post-meta><span class=post-date>June 26, 2018</span></div><span class=post-tags>#<a href=/tags/networking/>Networking</a>&nbsp;</span><div class=post-content><div><p>Most of us are familiar with SSH (Secure Shell) - a protocol which allows us to securely log onto remote systems. SSH Tunneling (also known as SSH Port Forwarding) is a feature of SSH which forwards encrypted connections between a local and remote system. SSH tunneling works by using the already established SSH connection for sending additional network traffic.</p><p>We&rsquo;re going to look at the three types of port forwarding - local, remote & dynamic.</p><h2 id=local-port-forwarding>Local port forwarding<a href=#local-port-forwarding class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Let&rsquo;s see what the man page for SSH tells us about <code>local</code></p><pre><code>local: -L
Specifies that the given port on the local (client) host is to be forwarded to the given host and port on the remote side.
</code></pre><p>So generically, the command would look something like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -L sourcePort:forwardToHost:destPort connectToHost
</code></pre></div><p>This translates to - connect with ssh to <code>connectToHost</code>, and forward all connection attempts to the <strong>local</strong> <code>sourcePort</code> to port <code>destPort</code> on the machine called <code>forwardToHost</code>, which can be reached from the <code>connectToHost</code> machine. Forwarding can also be done using Unix sockets.</p><p>Say YouTube is blocked on your office network, and you reaaaalllyy wanna watch some kitty videos. So, you can get around it by creating a tunnel through a server which isn&rsquo;t on your network and access YouTube. The above command can be translated to :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -L 9000:youtube.com:80 user@example.com
</code></pre></div><p>The <code>-L</code> flag here signfies that we&rsquo;re doing local port forwarding. We connect with the <code>user@example.com</code> machine. We then forward any connection to port 9000 on the local machine to port 80 (which is the default port for HTTP) on <code>youtube.com</code>. Now, if you open your browser and go to <code>http://localhost:9000</code> , a request is made to HTTP server listening on <code>youtube.com</code>. However, you, on your local machine, have no webserver running.</p><p>You still won&rsquo;t be able to the see homepage - so don&rsquo;t worry about that.</p><p>The requests in the browser for <code>localhost:9000</code> are built with a Host Destination header of localhost value. This request reaches <code>youtube.com</code> machine. But this request is ignored with an error message - <code>Invalid virtual host ..</code> because localhost cannot be a domain name on the server which is running <code>youtube</code>.</p><p>To fix this, we change the Host HTTP header enabling remote web server to identify the corresponding destination.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -H <span style=color:#e6db74>&#34;Host: youtube.com&#34;</span> -L localhost:9000
</code></pre></div><p><code>-L</code> parameter in curl is for following redirects. You should now be able to see the contents of homepage from <code>youtube.com</code> on <code>localhost:9000</code> as long as you are connected to <code>user@example.com</code> machine.</p><p>Also! The good things about SSH tunnels is that they are encrypted, so nobody can see what sites you are visiting - only an SSH connection to your server. (Take that, Office admins!! 😎)</p><p>By default, anyone (even on different machines) can connect to the specified port on the local machine. This can be restricted to programs on the same host by supplying a bind address:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -L 127.0.0.1:9000:youtube.com:80 user@example.com
</code></pre></div><p>SSH binds to port 9000 on the local machine. Any traffic that comes to this port is sent to the SSH server that listens on <code>user@example.com</code> - the remote machine. Once received by remote-machine, the traffic is then sent to port 80 of 127.0.0.1, which is <code>user@example.com</code> itself.</p><h3 id=connecting-to-a-database-behind-a-firewall>Connecting to a database behind a firewall<a href=#connecting-to-a-database-behind-a-firewall class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>forwardToHost</code> host may also refer to the remote machine through which the ssh connection is made (i.e. <code>connectToHost</code>) - in which case, the value for <code>forwardToHost</code> becomes 127.0.0.1 or localhost, as its local in the context of already established connection with <code>connectToHost</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -L 9000:127.0.0.1:80 user@example.com
</code></pre></div><p>An example for this is when you need to connect to a database console, which only allows local connection for security reasons, running PostgreSQL on your server, which by default listens on the port 5432.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -L 9000:localhost:5432 user@example.com
</code></pre></div><p>This command forwards the local port 9000 to the port 5432 on the remote machine. You can connect to that remote PostgreSQL server through the local machine using psql on localhost:9000, simply like :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ psql -h localhost -p <span style=color:#ae81ff>9000</span>
</code></pre></div><p>Let&rsquo;s take a moment here and understand what is actually going on.</p><p>In the YouTube example, <code>9000:youtube.com:80</code> says - forward my local port 9000 to <code>youtube.com</code> at port 80. So SSH on your server actually makes a tunnel (connection) between those two ports - one of which lies on your local machine, and another on target machine.</p><p>In the example of database connection, <code>9000:localhost:5432</code> means localhost from server&rsquo;s perspective, not localhost on your machine. In other words - forward my local port 9000 to port 5432 on the server - because when you&rsquo;re on the server, localhost means server itself.</p><p>Port numbers less than 1024 or greater than 49151 are reserved for the system, and can only be forwarded by root. If you&rsquo;re using port forwarding of any kind, you need to specifiy the destination server, i.e. <code>connectToHost</code>.</p><p>Port forwarding is enabled by default. If not, check <code>AllowTcpForwarding</code> in <code>/etc/ssh/sshd_config</code>.</p><h2 id=remote-port-forwarding>Remote port forwarding<a href=#remote-port-forwarding class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Going back to the man-page again to see the definition of <code>remote</code></p><pre><code>remote: -R
Specifies that the given port on the remote (server) host is to be forwarded to the given host and port on the local side.
</code></pre><p>The command would look much like local tunneling&rsquo;s but with an <code>-R</code> flag.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -R sourcePort:forwardToHost:destPort connectToHost
</code></pre></div><p>This translates to - connect with ssh to <code>connectToHost</code>, and forward all connection attempts to the <strong>remote</strong> <code>sourcePort</code> to port <code>destPort</code> on the machine called <code>forwardToHost</code>, which can be reached from the <code>connectToHost</code> machine. Forwarding can also be done using Unix sockets.</p><p>Okay! Let&rsquo;s see an example.</p><p>Say you&rsquo;re developing an application on your local machine and you&rsquo;d like to show the prototype to your boss.</p><p>In most cases, the ISP doesn&rsquo;t provide you with a public IP address, so you cannot connect your machine directly via the internet. While this problem can be solved by configuring NAT (Network Address Translation) on your router - this might not always work, there&rsquo;s a technical overhead of changing the configuration of your router, and you would need the admin access on your network.</p><p>In such a scenario, you can setup a server on internet which is publicly accessible and has SSH access. Then we tell SSH to make a tunnel that opens up a new port on server, and you connect to it via local port on your machine.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -R 9000:localhost:3000 user@example.com
</code></pre></div><p>The syntax here is very similar to local port forwarding, with a single change of <strong>-L</strong> for <strong>-R</strong>.</p><p>SSH will connect to the remote machine - in this case <code>user@example.com</code>. The flag <strong>-R</strong> makes ssh listen on the port 9000 of that machine. Once there&rsquo;s a process on the machine connecting to 9000, the ssh server listening on the same machine will transfer that connection to local machine - the machine that initiated the ssh communication - and forward it to localhost on the port 3000.</p><p>Remote port forwarding allows to map a port of the local machine onto the remote server via SSH.</p><p>Another thing which you need to do is to set <code>GatewayPorts</code>. In your <code>/etc/ssh/sshd_config</code> , set</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>GatewayPorts yes
</code></pre></div><p>And restart SSH</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo service ssh restart
</code></pre></div><p>This allows the SSH server to bind port 3000 to the wildcard address - such that the port becomes available to the public address of the <code>connectToHost</code> remote machine.</p><p>You can also set <code>GatewayPorts</code> to <code>clientspecified</code> - in which case, the remote port will not bind on the wildcard address. You might need to explicitly specify an empty bind address for binding the wildcard address - which can be done by prefixing remote port with <code>:</code> sign.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -R :9000:localhost:3000 user@example.com
</code></pre></div><p>You can also specify an IP address from which connections to the port are allowed, such that only connections from the given IP address to the given port are allowed.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -R 1.2.3.4:9000:localhost:3000 user@example.com
</code></pre></div><p>Now your boss will be able to access your application on port 3000 by pointing their browser to <code>connectToHost</code> IP address on the port 9000.</p><h3 id=double-forwarding>Double forwarding<a href=#double-forwarding class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If the remote server has <code>GatewayPorts</code> set to <code>no</code>, with no possibility of changing it - you can execute the remote forwarding above followed by a local forwarding using <code>-g</code> option, but from the remote server.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -g -L 9000:localhost:3000 user@example.com
</code></pre></div><p><strong>-g</strong> allows remote hosts to connect to local forwarded ports and this will make loopback port 3000 on the server accessible on all interfaces on port 9000.</p><h2 id=dynamic-port-forwarding---socks>Dynamic port forwarding - SOCKS<a href=#dynamic-port-forwarding---socks class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Dynamic port forwarding allows communication across a range of ports. This port forwarding is created using a <strong>-D</strong> parameter. This makes SSH acts as a <a href=https://en.wikipedia.org/wiki/SOCKS>SOCKS proxy server</a>.</p><p>There&rsquo;s two kinds of SOCKS protocols - SOCKS4 and SOCKS5. These are basically internet protocols which route packets between a server and a client using proxy server. SOCKS5 uses both TCP and UDP, whereas SOCKS4 uses only TCP.</p><p>A SOCKS proxy is a simple SSH tunnel in which specific applications forward their traffic through the tunnel to the remote server, then the proxy forwards the traffic out to the general internet. Unlike a VPN, SOCKS proxy has to be configured for each application separately on the client machine.</p><p>Dynamic port forwarding can handle connections from multiple ports. It analyses the traffic to determine the destination for given connection. However, you might need to configure programs to use a SOCKS proxy server.</p><p>This can be done by :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -D <span style=color:#ae81ff>9000</span> -f -C -q -N connectToHost
</code></pre></div><p><strong>-D</strong> tells SSH to create a SOCKS tunnel on the the port 9000.</p><p><strong>-f</strong> forks the process to the background.</p><p><strong>-C</strong> compresses the data before sending it.</p><p><strong>-q</strong> enables quiet mode.</p><p><strong>-N</strong> tells SSH that no command will be sent once the tunnel is up.</p><p>A downside to using proxies is decreased performance and mislabelled errors as they rewrite data packet headers. With SOCKS5 proxy, the server does not rewrite data packet headers - hence being more performant and less prone to data routing errors. Because SOCK5 proxies they are low-level, they can work with any kind of data traffic - program, protocol etc.</p><h2 id=closing-tip>Closing Tip!<a href=#closing-tip class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The <code>-nNT</code> flags will cause SSH to not allocate a tty and only do the port forwarding. This will prevent the creation of shell everytime you create a tunnel.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh -nNT -L 9000:youtube.com:80 user@example.com
</code></pre></div><h3 id=more-reading>More reading<a href=#more-reading class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><a href="https://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html?utm_source=cronweekly.com">SSH Tunneling</a></li><li><a href=https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work>UnixSE - how does ssh tunneling work</a></li><li><a href=https://unix.stackexchange.com/a/19624>UnixSE - ssh port forward to access my home machine from anywhere</a></li><li><a href=https://vimeo.com/54505525>The Black Magic Of SSH / SSH Can Do That?</a> - This is a video.</li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/retries-timeouts-backoff/><span class=button__icon>←</span>
<span class=button__text>Retries, Timeouts and Backoff</span></a></span>
<span class="button next"><a href=/posts/lenses-part-1/><span class=button__text>Haskell Lens - Part 1</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by panr</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>