<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="/posts/atoms/"><link rel=canonical href=/posts/atoms/><link rel=alternate type=application/atom+xml href=/index.xml><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Clojure - Atoms","headline":"Clojure - Atoms","description":"In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.\nIn simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.\nLet’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2017","datePublished":"2017-12-26 12:39:46 \x2b0530 \x2b0530","dateModified":"2017-12-26 12:39:46 \x2b0530 \x2b0530","url":"\/posts\/atoms\/","keywords":["Clojure"]}</script><title>Clojure - Atoms -</title><meta property="og:title" content="Clojure - Atoms -"><meta property="og:type" content="article"><meta property="og:description" content="In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl."><meta name=description content="In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Clojure - Atoms</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2017-12-26 12:39:46 +0530">26 Dec 2017</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><p>In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where <code>Atom</code> enter the picture.</p><p>In simple words, atom in Clojure is a built-in mechanism to manage application state. <code>Atoms</code> are mutable, and can be updated as many times as you want.</p><p>Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>use</span> <span class=ss>&#39;clojure.repl</span><span class=p>)</span>
<span class=nv>user&gt;</span> <span class=p>(</span><span class=nb>doc </span><span class=nv>atom</span><span class=p>)</span>

<span class=nv>-------------------------</span>
<span class=nv>clojure.core/atom</span>
<span class=p>(</span><span class=p>[</span><span class=nv>x</span><span class=p>]</span> <span class=p>[</span><span class=nv>x</span> <span class=o>&amp;</span> <span class=nv>options</span><span class=p>]</span><span class=p>)</span>
  <span class=nv>..</span>
<span class=c1>;; =&gt; nil</span>
</code></pre></div><p>Now we know how to create an <code>Atom</code>. So let’s go ahead and define an atom which points to a value; say &ldquo;pikachu&rdquo;. This is just for simplicity, the atom can point to any thing; an int 1, a map <code>{:a "apple" :b "boogy"}</code> ; you can create an atom of any values.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=k>def </span><span class=nv>atom-str</span> <span class=p>(</span><span class=nf>atom</span> <span class=s>&#34;pikachu&#34;</span><span class=p>)</span><span class=p>)</span>
<span class=c1>;; =&gt; #&#39;user/atom-str</span>
</code></pre></div><p>The value of <code>atom-str</code> can be obtained in two ways</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=o>@</span><span class=nv>atom-str</span>

<span class=nv>--</span> <span class=nv>Or</span>

<span class=nv>user&gt;</span> <span class=p>(</span><span class=nb>deref </span><span class=nv>atom-str</span><span class=p>)</span>
<span class=c1>;; =&gt; &#34;pikachu&#34;</span>
</code></pre></div><h3 id=swap-and-reset>Swap! and Reset!</h3><p><strong>Note :</strong> Exclamation mark <code>(!)</code> means that this function has side-effects. i.e. it changes state for atoms, metadata, vars, transients, agents and io as well</p><p><code>swap!</code> allows us to use a function to update the value of an atom. Let’s look at how to use <code>swap!</code>.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nb>doc </span><span class=nv>swap!</span><span class=p>)</span>

<span class=nv>-------------------------</span>
<span class=nv>clojure.core/swap!</span>
<span class=p>(</span><span class=p>[</span><span class=nv>atom</span> <span class=nv>f</span><span class=p>]</span> <span class=p>[</span><span class=nv>atom</span> <span class=nv>f</span> <span class=nv>x</span><span class=p>]</span> <span class=p>[</span><span class=nv>atom</span> <span class=nv>f</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>]</span> <span class=p>[</span><span class=nv>atom</span> <span class=nv>f</span> <span class=nv>x</span> <span class=nv>y</span> <span class=o>&amp;</span> <span class=nv>args</span><span class=p>]</span><span class=p>)</span>
  <span class=nv>..</span>
<span class=c1>;; =&gt; nil</span>

</code></pre></div><p>The function used to update the value should be pure ; because <code>swap!</code> internally uses <code>compare-and-set!</code> to update the value atomically. And failures could make <code>swap!</code> re-run the function. Hence, it is important the function returns a value without interacting with any other part of the system; and thus should be free of side effects.</p><p>Let’s use swap! to add a string <code>"_new"</code> at the end of our atom.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>swap!</span> <span class=nv>atom-str</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>value</span><span class=p>]</span> <span class=p>(</span><span class=nb>str </span><span class=nv>value</span> <span class=s>&#34;_new&#34;</span><span class=p>)</span><span class=p>)</span><span class=p>)</span>
<span class=c1>;; =&gt; &#34;pikachu_new&#34;</span>
</code></pre></div><p><code>reset!</code> changes the current value of atom; without caring what the current value is.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>reset!</span> <span class=nv>atom-str</span> <span class=s>&#34;bulbasaur&#34;</span><span class=p>)</span>
<span class=c1>;; =&gt; &#34;balbasaur&#34;</span>
</code></pre></div><p><strong>Use swap! if you need to use the current value to determine the new value.</strong></p><p>Another example to illustrate the difference between <code>swap!</code> and <code>reset!</code> is</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>atom-int</span> <span class=p>(</span><span class=nf>atom</span> <span class=mi>1</span><span class=p>)</span><span class=p>)</span>
<span class=p>(</span><span class=nf>swap!</span> <span class=nv>atom-int</span> <span class=nv>inc</span><span class=p>)</span>   <span class=c1>; @x is now 2</span>
<span class=p>(</span><span class=nf>reset!</span> <span class=nv>atom-int</span> <span class=mi>100</span><span class=p>)</span>  <span class=c1>; @x is now 100</span>
<span class=p>(</span><span class=nf>swap!</span> <span class=nv>atom-int</span> <span class=nv>inc</span><span class=p>)</span>   <span class=c1>; @x is now 101</span>
</code></pre></div><h3 id=threadsafety>Threadsafety</h3><p><code>Atoms</code> are threadsafe. Atomic mutable state with immutable values gives you composable concurrency semantics. They can be understood as similar to mutable variables in other programming languages.</p><p>Values can be assigned and updated any time. The value will be updated by one thread at one time using swap!. And since it uses pure function; it is safe to say that the process has no side effects. You could also use locks with vars, but it is undeterministic to say what the final value will be, since the code will be executed in parallel on different threads.</p><p>Exercise : Update a nested map in an atom thread-safely.</p><div class=highlight><pre class=chroma><code class=language-clojure data-lang=clojure><span class=nv>user&gt;</span> <span class=p>(</span><span class=k>def </span><span class=nv>nested-map</span> <span class=p>(</span><span class=nf>atom</span> <span class=p>{</span><span class=ss>:id</span> <span class=p>{</span><span class=ss>:count</span> <span class=mi>0</span><span class=p>}</span><span class=p>}</span><span class=p>)</span><span class=p>)</span>
<span class=c1>;; =&gt; #&#39;user/nested-map</span>

<span class=nv>user&gt;</span> <span class=p>(</span><span class=kd>defn </span><span class=nv>update-count</span> <span class=p>[</span><span class=nv>id</span><span class=p>]</span>
  <span class=p>(</span><span class=nf>swap!</span> <span class=nv>nested-map</span> <span class=nv>update-in</span> <span class=p>[</span><span class=p>(</span><span class=nb>keyword </span><span class=nv>id</span><span class=p>)</span> <span class=ss>:count</span><span class=p>]</span> <span class=nv>inc</span><span class=p>)</span><span class=p>)</span>
<span class=c1>;; =&gt; #&#39;user/update-count</span>

<span class=nv>user&gt;</span> <span class=p>(</span><span class=nf>update-count</span> <span class=s>&#34;id&#34;</span><span class=p>)</span>
<span class=c1>;; =&gt; {:id {:count 1}}</span>
</code></pre></div><h3 id=conclusion>Conclusion</h3><p><code>atom</code> is the state; and mutable object. value is immutable, it can be shared by threads without having any change to it’s value. Atoms guarantee that no matter how many threads are trying to change the value, each change is calculated from previous value; and no previous values are lost.</p><p>Atoms basically provide user with a way to make immutable data structures and concurrency primitives to manage state collectively. In Clojure there is a distinct separation of value and state, and this is how Clojure helps with concurrency.</p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>