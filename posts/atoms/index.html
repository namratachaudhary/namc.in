<!doctype html><html lang=en><head><title>Clojure - Atoms :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl."><meta name=keywords content="Clojure,Atoms"><meta name=robots content="noodp"><link rel=canonical href=/posts/atoms/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Clojure - Atoms :: __namc —"><meta name=twitter:description content="In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Clojure - Atoms :: __namc —"><meta property="og:description" content="In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where Atom enter the picture.
In simple words, atom in Clojure is a built-in mechanism to manage application state. Atoms are mutable, and can be updated as many times as you want.
Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl."><meta property="og:url" content="/posts/atoms/"><meta property="og:site_name" content="Clojure - Atoms"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2017-12-26 12:39:46 +0530 +0530"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/atoms/>Clojure - Atoms</a></h1><div class=post-meta><span class=post-date>December 26, 2017</span></div><span class=post-tags>#<a href=/tags/clojure/>Clojure</a>&nbsp;</span><div class=post-content><div><p>In Clojure, everything is immutable! So how can Clojure be used to build stateful applications? That’s where <code>Atom</code> enter the picture.</p><p>In simple words, atom in Clojure is a built-in mechanism to manage application state. <code>Atoms</code> are mutable, and can be updated as many times as you want.</p><p>Let’s look at a practical example to understand the usage and implications of atom . We begin by looking up the documentation of atom in repl.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>use</span> <span style=color:#e6db74>&#39;clojure.repl</span>)
user&gt; (doc atom)

-------------------------
clojure.core/atom
([x] [x <span style=color:#f92672>&amp;</span> options])
  ..
<span style=color:#75715e>;; =&gt; nil</span>
</code></pre></div><p>Now we know how to create an <code>Atom</code>. So let’s go ahead and define an atom which points to a value; say &ldquo;pikachu&rdquo;. This is just for simplicity, the atom can point to any thing; an int 1, a map <code>{:a "apple" :b "boogy"}</code> ; you can create an atom of any values.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>atom-str (<span style=color:#a6e22e>atom</span> <span style=color:#e6db74>&#34;pikachu&#34;</span>))
<span style=color:#75715e>;; =&gt; #&#39;user/atom-str</span>
</code></pre></div><p>The value of <code>atom-str</code> can be obtained in two ways</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; <span style=color:#f92672>@</span>atom-str

-- Or

user&gt; (deref atom-str)
<span style=color:#75715e>;; =&gt; &#34;pikachu&#34;</span>
</code></pre></div><h3 id=swap-and-reset>Swap! and Reset!<a href=#swap-and-reset class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>Note :</strong> Exclamation mark <code>(!)</code> means that this function has side-effects. i.e. it changes state for atoms, metadata, vars, transients, agents and io as well</p><p><code>swap!</code> allows us to use a function to update the value of an atom. Let’s look at how to use <code>swap!</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (doc swap!)

-------------------------
clojure.core/swap!
([atom f] [atom f x] [atom f x y] [atom f x y <span style=color:#f92672>&amp;</span> args])
  ..
<span style=color:#75715e>;; =&gt; nil</span>

</code></pre></div><p>The function used to update the value should be pure ; because <code>swap!</code> internally uses <code>compare-and-set!</code> to update the value atomically. And failures could make <code>swap!</code> re-run the function. Hence, it is important the function returns a value without interacting with any other part of the system; and thus should be free of side effects.</p><p>Let’s use swap! to add a string <code>"_new"</code> at the end of our atom.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>swap!</span> atom-str (<span style=color:#66d9ef>fn </span>[value] (str value <span style=color:#e6db74>&#34;_new&#34;</span>)))
<span style=color:#75715e>;; =&gt; &#34;pikachu_new&#34;</span>
</code></pre></div><p><code>reset!</code> changes the current value of atom; without caring what the current value is.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#a6e22e>reset!</span> atom-str <span style=color:#e6db74>&#34;bulbasaur&#34;</span>)
<span style=color:#75715e>;; =&gt; &#34;balbasaur&#34;</span>
</code></pre></div><p><strong>Use swap! if you need to use the current value to determine the new value.</strong></p><p>Another example to illustrate the difference between <code>swap!</code> and <code>reset!</code> is</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>atom-int (<span style=color:#a6e22e>atom</span> <span style=color:#ae81ff>1</span>))
(<span style=color:#a6e22e>swap!</span> atom-int inc)   <span style=color:#75715e>; @x is now 2</span>
(<span style=color:#a6e22e>reset!</span> atom-int <span style=color:#ae81ff>100</span>)  <span style=color:#75715e>; @x is now 100</span>
(<span style=color:#a6e22e>swap!</span> atom-int inc)   <span style=color:#75715e>; @x is now 101</span>
</code></pre></div><h3 id=threadsafety>Threadsafety<a href=#threadsafety class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>Atoms</code> are threadsafe. Atomic mutable state with immutable values gives you composable concurrency semantics. They can be understood as similar to mutable variables in other programming languages.</p><p>Values can be assigned and updated any time. The value will be updated by one thread at one time using swap!. And since it uses pure function; it is safe to say that the process has no side effects. You could also use locks with vars, but it is undeterministic to say what the final value will be, since the code will be executed in parallel on different threads.</p><p>Exercise : Update a nested map in an atom thread-safely.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>nested-map (<span style=color:#a6e22e>atom</span> {<span style=color:#e6db74>:id</span> {<span style=color:#e6db74>:count</span> <span style=color:#ae81ff>0</span>}}))
<span style=color:#75715e>;; =&gt; #&#39;user/nested-map</span>

user&gt; (<span style=color:#66d9ef>defn </span>update-count [id]
  (<span style=color:#a6e22e>swap!</span> nested-map update-in [(keyword id) <span style=color:#e6db74>:count</span>] inc))
<span style=color:#75715e>;; =&gt; #&#39;user/update-count</span>

user&gt; (<span style=color:#a6e22e>update-count</span> <span style=color:#e6db74>&#34;id&#34;</span>)
<span style=color:#75715e>;; =&gt; {:id {:count 1}}</span>
</code></pre></div><h3 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>atom</code> is the state; and mutable object. value is immutable, it can be shared by threads without having any change to it’s value. Atoms guarantee that no matter how many threads are trying to change the value, each change is calculated from previous value; and no previous values are lost.</p><p>Atoms basically provide user with a way to make immutable data structures and concurrency primitives to manage state collectively. In Clojure there is a distinct separation of value and state, and this is how Clojure helps with concurrency.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/protocols/><span class=button__icon>←</span>
<span class=button__text>Structured Clojure: Protocols</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by [panr](https://twitter.com/panr)</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>