<!doctype html><html lang=en><head><title>Haskell Lens - Part 1 :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead."><meta name=keywords content="haskell,lens"><meta name=robots content="noodp"><link rel=canonical href=/posts/lenses-part-1/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Haskell Lens - Part 1 :: __namc —"><meta name=twitter:description content="Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Haskell Lens - Part 1 :: __namc —"><meta property="og:description" content="Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&amp;rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&amp;rsquo;d like to give a heads-up about few things, so you know what lies ahead."><meta property="og:url" content="/posts/lenses-part-1/"><meta property="og:site_name" content="Haskell Lens - Part 1"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-03-26 13:00:58 +0530 +0530"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/lenses-part-1/>Haskell Lens - Part 1</a></h1><div class=post-meta><span class=post-date>March 26, 2018</span></div><span class=post-tags>#<a href=/tags/haskell/>Haskell</a>&nbsp;</span><div class=post-content><div><h2 id=preface>Preface<a href=#preface class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>lens</code> are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&rsquo;ll learn something in the process, and you will too (hopefully!).</p><p>Before we begin, I&rsquo;d like to give a heads-up about few things, so you know what lies ahead.</p><ol><li><p>I am assuming if you&rsquo;re here, you have a fair amount of idea about <code>Monoids</code>, <code>Monads</code>, <code>Functors</code>, <code>Applicatives</code>. If you&rsquo;re not very familiar with the concepts, here is a list of suggested reading.</p><ul><li><a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids>Applicative Monads</a></li><li><a href=https://namc.in/2018-01-12-applicative-functors>Applicative Functors</a></li><li><a href=http://learnyouahaskell.com/a-fistful-of-monads>LYAH</a></li><li><a href=http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>Functors, Applicatives, And Monads In Pictures</a></li></ul></li><li><p>In my opnion, you should probably get comfortable with those concepts before proceeding with lenses.</p></li><li><p>This is the most important part. I&rsquo;m learning as I write this post. So if you feel I&rsquo;m wrong about something, please do leave a note, and I&rsquo;d be more than happy to correct myself.</p></li></ol><hr><h2 id=introduction>Introduction<a href=#introduction class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The <code>lens</code> library allows us to query and update some value in deeply nested records. Well, that&rsquo;s the simplest problem it solves. So let&rsquo;s see some examples for better understanding.</p><p>The example I&rsquo;ve selected is close to a project I did.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- line.hs</span>

<span style=color:#75715e>{-</span><span style=color:#75715e># LANGUAGE TemplateHaskell #</span><span style=color:#75715e>-}</span>

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Line</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Line</span> { _start <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>, _end <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>} <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> { _x <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span>, _y <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span> } <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)
</code></pre></div><p>Let&rsquo;s try to define a few getters and setters!</p><p>Keep in mind! We haven&rsquo;t <em>yet</em> started using Lenses, so we will do it the old school way!</p><p>Setter =></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- helper functions to make Point and Line</span>

<span style=color:#a6e22e>makePoint</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Double</span>, <span style=color:#66d9ef>Double</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Point</span>
<span style=color:#a6e22e>makePoint</span> (x, y) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> x y

<span style=color:#a6e22e>makeLine</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Double</span>, <span style=color:#66d9ef>Double</span>) <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Double</span>, <span style=color:#66d9ef>Double</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Line</span>
<span style=color:#a6e22e>makeLine</span> start end <span style=color:#f92672>=</span> <span style=color:#66d9ef>Line</span> (makePoint start) (makePoint end)
</code></pre></div><p>Now since data is immutable, you&rsquo;d actually be creating a new point/line with given parameters.</p><p>Getters =></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> makeLine (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>) (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>)

<span style=color:#75715e>-- Record syntax gives functions for accessing the fields</span>
<span style=color:#75715e>-- following gives the _y coordinate of _end of line</span>

<span style=color:#f92672>&gt;</span> _y <span style=color:#f92672>.</span> _end <span style=color:#f92672>$</span> line
</code></pre></div><p>Now consider you want to change the <code>_x</code> position of <code>_start</code> point of the <code>line</code> we have defined above, you have to write this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>line2</span> <span style=color:#f92672>=</span> line { _start <span style=color:#f92672>=</span> (_start line) { _x <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span> } }
</code></pre></div><p>It works, but it looks clumsy. And it definitely gets tougher to pack/upack data as more fields are added to each data type! Or if your data becomes more deeply nested.</p><p>This is because you need to re-create all of the wrapping objects around the value that you are changing, because Haskell values are immutable.</p><h2 id=simple-lens>Simple Lens<a href=#simple-lens class=hanchor arialabel=Anchor>&#8983;</a></h2><p>A lens, by definition, is a first class getter and setter.</p><p><strong>What do you mean by first-class?</strong></p><p>A function is called <code>first class</code> when you can manipulate them using ordinary functional programming ways. You can pass them around the same way as integers, sequences.</p><ul><li>Can be used without restrictions - put in containers, passed as input and returned as output from functions</li><li>Can be constructed without restrictions - locally, globally, in-exression</li></ul><p>More details can be read <a href=http://freecontent.manning.com/learning-haskell-first-class-functions/>here</a>. The above definition is more than enough.</p><p>Lenses package <code>get</code> and <code>set</code> functionality into a single value. So you can loosely say, that lens is a record with two fields <code>view</code> and <code>set</code> and can be defined as</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens</span>
  { view <span style=color:#f92672>::</span> s <span style=color:#f92672>-&gt;</span> a
  , set <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s }
</code></pre></div><p>Well, that&rsquo;s not how a lens is actually implemented, but it is the intuition. The above definition helps us define our lenses .</p><p>Lens comes in very handy in situation where data is deeply nested. What Lens typically does is; it groups two things together corresponding to a data structure:</p><ol><li>The view of a value (like <code>_x</code> and <code>_end</code> given above).</li><li>A corresponding function.</li></ol><p>Lenses combine 1 & 2, and give us the ability to read the values in the data structure, create new data structures with the value changed.</p><p>Going back the example we started with;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> { _x <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span>, _y <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span> }

<span style=color:#75715e>-- The &#34;view&#34; of the point variable _x</span>

<span style=color:#a6e22e>viewX</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span>
<span style=color:#a6e22e>viewX</span> p <span style=color:#f92672>=</span> _x p

<span style=color:#75715e>-- The &#34;set&#34; or &#34;update&#34; of point variable _x</span>

<span style=color:#a6e22e>setX</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Point</span>
<span style=color:#a6e22e>setX</span> p x <span style=color:#f92672>=</span> p { _x <span style=color:#f92672>=</span> x }

<span style=color:#75715e>-- Now the lens combines view and set; by definiton</span>

<span style=color:#a6e22e>xLens</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Point</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span>, <span style=color:#66d9ef>Point</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Point</span>)
<span style=color:#a6e22e>xLens</span> <span style=color:#f92672>=</span> (viewX, setX)
</code></pre></div><p>There you have it! You&rsquo;ve successfully defined your first <code>Lens</code> !</p><p>Now there any many, many ways of defining lenses.</p><p>We will go more into detail about the <code>:type</code> of lenses.</p><p>According to our definition above, we can abstract out the type of lens as</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens&#39;</span>
                     { view   <span style=color:#f92672>::</span> s <span style=color:#f92672>-&gt;</span> a
                     , over   <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s}
</code></pre></div><p>i.e.; it is the combination of a view, and a set for some type <code>s</code> which has a field of type <code>a</code> .</p><p>The <code>xLens</code> above would be of type <code>Lens' Point Double</code> .</p><p>But the problem with this approach of writing a getter and a setter into a data type is that it doesnt scale very well.</p><p>If we wanted to do something like - increment the value of some field by 1, first we will have to define a getter for that field, then apply <code>+ 1</code> to it and then define a setter to set the new value.</p><p>We can try to combine this entire process, by providing another function to <code>Lens'</code> : <code>over</code> .</p><p>You can think of <code>over</code> as similar to <code>set</code> , with slightly different defintion, i.e. <code>over</code> can be understood as combinator for setters. It works a lot like fmap, except that you pass a setter as it&rsquo;s first argument to specify which part of the data structure you want to focus on.</p><p>In fact, you could use this similarly to <code>set</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- using over to move _x by +1</span>

<span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> s)

<span style=color:#66d9ef>let</span> p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> { _x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, _y <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> }
<span style=color:#a6e22e>over</span> xLens (<span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) p1
</code></pre></div><p>Okay, let&rsquo;s look back at our definition of <code>xLens</code> ; and see if we can redefine the definition of our lens using over.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- xLens :: (Point -&gt; Double, Point -&gt; Double -&gt; Point)</span>
<span style=color:#75715e>-- using &#34;over&#34;</span>

<span style=color:#a6e22e>xLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Point</span> <span style=color:#66d9ef>Double</span>
<span style=color:#a6e22e>xLens</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens&#39;</span> _x
                (<span style=color:#a6e22e>\</span>a s <span style=color:#f92672>-&gt;</span> s { _x <span style=color:#f92672>=</span> a })           <span style=color:#75715e>-- getter</span>
                (<span style=color:#a6e22e>\</span>f s <span style=color:#f92672>-&gt;</span> s { _x <span style=color:#f92672>=</span> f (_x s) })    <span style=color:#75715e>-- over</span>
</code></pre></div><p>Good so far!</p><p>But the problem now is that for each lens, we will have to provide a <code>view</code>, a <code>set</code> and <code>over</code> even if we&rsquo;re just using one of them!</p><p>We can solve this by using <code>const</code> .</p><p>It has a type <code>s -> a -> s</code> which allows us to write <code>over :: (a -> a) -> (s -> s)</code> as <code>set :: s -> a -> s</code> by partially applying it. In other words, we can rewrite <code>set</code> as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>set</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> a
<span style=color:#a6e22e>set</span> xLens s a <span style=color:#f92672>=</span> over xLens (const s) a
</code></pre></div><p>So the final definition of our lens looks like this :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens&#39;</span>
                     { view <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> s
                     , over <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s }

<span style=color:#a6e22e>set</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> a
<span style=color:#a6e22e>set</span> xLens s a <span style=color:#f92672>=</span> over xLens (const s) a
</code></pre></div><p>Okay, so recap time!</p><ul><li>We saw how to define lenses using <code>view</code>, <code>set</code> and <code>over</code></li><li>We saw how to define <code>view</code> to retrieve value and <code>set</code>/<code>over</code> to retrieve values.</li><li>We also saw how we can rewrite <code>set</code>.</li></ul><p>Going back to definition : lenses package both &ldquo;get&rdquo; and &ldquo;set&rdquo; functionality into a single value (the lens).</p><p>You could pretend that a lens is a record with two fields:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens&#39;</span>
    { view <span style=color:#f92672>::</span> s <span style=color:#f92672>-&gt;</span> a
    , over <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> s)
    }
</code></pre></div><p>This looks a little different from our initial defintion, and if you have followed the transition so far, you probably understand why.</p><h2 id=using-functors>Using functors<a href=#using-functors class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So far, we have seen how <code>over</code> can be used to reach nested nodes of a data structure. But the functionality was more related to <code>insert</code> than <code>update</code> . What if the modifier function needs to perform modifications where there are some side effects?</p><p>E.g. : We might want to print the value to the console; which is an IO function.</p><p>Just like before, we could add another function, using IO data type :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- new definition of lens</span>

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Lens&#39;</span>
                     { view   <span style=color:#f92672>::</span> s <span style=color:#f92672>-&gt;</span> a
                     , over   <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s
                     , overIO <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> s }
</code></pre></div><p>Again, there are some issues with the above implementation</p><ul><li>The definition of lens has grown again, and we would like very much to avoid that</li><li>What if <code>over</code> is used in more settings than just <strong>IO</strong>? Would we define new functions for the same?</li></ul><p>At this point we would like to revisit the definition of <code>over</code> and try to generalize it. You must have noticed, to define <code>overIO</code> we added <code>IO</code> .</p><p>We can easily swap IO for a more generalised type -> <strong>Functor</strong> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s
</code></pre></div><p>Now here is an interesting argument. <code>over</code> is typically a functor modified, ie. – it does what the original functor does, but it also attaches a value to it. Similarly, we can pick what Functor we specialize <code>f</code> to , and depending on which Functor we pick, we get different defintions.</p><p>For example :</p><p><strong>(This is covered in more details in following sections)</strong></p><p>if you pick (f = Const t), you get a <code>view</code> like function</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Getter&#39;</span> a s a  <span style=color:#f92672>=</span> (a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Const</span> a a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Const</span> a s)

<span style=color:#75715e>--  equivalent to: (a -&gt; a) -&gt; (s -&gt; a)</span>
</code></pre></div><p>if you pick (f = Identity) , you get an <code>over</code> like function</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Setter&#39;</span> s a   <span style=color:#f92672>=</span> (a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> s)

<span style=color:#75715e>--  equivalent to: (a -&gt; a) -&gt; (s -&gt; s)</span>
</code></pre></div><p>Now since we can use functor to implement both; getters and setters; we can redefine our lens to following :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>-- new definition</span>

<span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s
</code></pre></div><p>By making this type an alias, instead of newtype or data, you can define your own lenses without depending on the lens library. Any function which has the appropriate type signature is a lens.</p><h2 id=rankntype>RankNType<a href=#rankntype class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Lens uses <a href=https://wiki.haskell.org/Rank-N_types>rank 2 types</a> ; i.e. <code>Lens'</code> type synonym is polymorphic and occurs in the signature in what is called &ldquo;negative position&rdquo;, that is, to the left of the <code>-></code> .</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

<span style=color:#75715e>-- This typechecks</span>
<span style=color:#a6e22e>checks</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> (s,t) s
<span style=color:#a6e22e>checks</span> <span style=color:#f92672>=</span> _1

<span style=color:#75715e>-- This fails with error &#34;Illegal polymorphic or qualified type: Lens&#39; s t&#34;</span>
<span style=color:#a6e22e>fails</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> (s,t) s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
<span style=color:#a6e22e>fails</span> <span style=color:#f92672>=</span> const <span style=color:#ae81ff>5</span>
</code></pre></div><p>Here the <strong>lens&rsquo;</strong> is in negative position, and ranges only over <code>s -> Int</code>. It is the implementation of <code>fails</code>, and not the caller of <code>fails</code>, the one who chooses the type of <code>s</code>. The caller must supply an argument function that works for all <code>s</code>.</p><p>Therefore it is imperetive to use :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>{-</span><span style=color:#75715e># LANGUAGE RankNTypes #</span><span style=color:#75715e>-}</span> <span style=color:#75715e>-- Rank2Types is a synonym for RankNTypes</span>
</code></pre></div><p>at the top of your file. Without it, it&rsquo;s illegal to even use a lens type synonym since they use a part of the language you must enable. And if you try to use lens without enabling <code>RankNTypes</code> it will throw <strong>Illegal polymorphic error</strong>.</p><h2 id=lens-type>Lens Type<a href=#lens-type class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So, the actual type for lenses is:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens</span> s t a b <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f t

<span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s
</code></pre></div><ul><li><a href=https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens><code>Lens</code></a> : Lens family as described in <a href=http://comonad.com/reader/2012/mirrored-lenses/>mirrored lenses</a></li><li><a href=https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-><code>Lens'</code></a> : Simple Lens, used whenever the type variables don&rsquo;t change upon setting a value.</li></ul><p>We&rsquo;ve already seen the derivation of <code>Lens'</code> type, in the previous section.</p><h3 id=different-forms-of-lenses>Different forms of lenses<a href=#different-forms-of-lenses class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Quick recap of a few things we covered so far (they will be handly in this section)</p><ul><li>Lens represent a getter and a setter into some data type.</li><li>Setter can be generalized to work with functions, by using <code>over</code></li><li>Generalized <code>over</code> to the <a href=https://github.com/ekmett/lens/wiki/History-of-Lenses>van Laarhoven lens</a> of <strong>Functor f => (a -> f a) -> s -> f s</strong> .</li><li>We saw how <code>Lens' s a</code> can behave like <code>over</code> , <code>set</code> and <code>view</code> .</li></ul><p>But what if you just need a simple modification, and no functors, or vice versa?</p><p>In this section, we are going to define different forms of lenses, prove it and understand why it works as intended. We will be using two Functor instances that come from the base library, namely <strong>Data.Functor.Identity</strong> and <strong>Control.Applicative.Const</strong>.</p><h3 id=lens-as-ordinary-setter>Lens as ordinary setter<a href=#lens-as-ordinary-setter class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If you just want to set or modify the value, use <code>Identity</code>, which is precisely the functor to use when you don&rsquo;t actually need one, because you can put a value in, let it behave as a functor and then the value out.</p><p><code>Identity</code> functor is defined as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>newtype</span> <span style=color:#66d9ef>Identity</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> { runIdentity <span style=color:#f92672>::</span> a }

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> <span style=color:#66d9ef>Identity</span> <span style=color:#66d9ef>where</span>
  fmap f (<span style=color:#66d9ef>Identity</span> a) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Identity</span> (f a)
</code></pre></div><p><code>Identity</code> is also the &ldquo;empty&rdquo; functor and applicative functor, which means, <code>Identity</code> composed with another functor or applicative functor is isomorphic to the original. <code>Lens'</code> is defined as a function polymorphic in a Functor, therefore we can represent the defintion of <code>Lens' s a</code> in terms of <code>Functor</code> in the definition of <code>over</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

<span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s

<span style=color:#75715e>-- can be rewritten as</span>
<span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> f s)) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s
</code></pre></div><p>Specializing <code>f</code> to <code>Identity</code> :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

(a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> s

<span style=color:#75715e>-- which is isomorphic to</span>
(a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s
</code></pre></div><p>so given an updating function on a, return an updating function on s.</p><p>As we have already established, the final form of <code>over</code> is</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s
</code></pre></div><p>i.e. : Given a lens with focus on <code>a</code> inside of <code>s</code> , and a function from <code>a</code> to <code>a</code> and <code>s</code> , you get back a modified <code>s</code> after applying the function <code>over</code> to the focus point of the lens.</p><p>Keep in mind that <code>Lens</code> is just a function, nothing more</p><p>Therefore, by substituting <code>Lens s a</code> by <code>Identity</code> functor we can define <code>over</code> as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> ((a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> s)) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s

<span style=color:#75715e>-- which helps us define</span>
<span style=color:#a6e22e>over</span> ln f x <span style=color:#f92672>=</span> runIdentity (ln (<span style=color:#a6e22e>\</span>y <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Identity</span> (f y)) x)

<span style=color:#75715e>{-</span><span style=color:#75715e>
</span><span style=color:#75715e>    Arguments :
</span><span style=color:#75715e>    ln :: (a </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Identity a) </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; (s </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Identity s)
</span><span style=color:#75715e>    f  :: a </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; a
</span><span style=color:#75715e>    x  :: a
</span><span style=color:#75715e></span><span style=color:#75715e>-}</span>

<span style=color:#75715e>-- a more syntactically pleasing version to write he above expression</span>
<span style=color:#75715e>-- could be by making use of point free style</span>
<span style=color:#a6e22e>over</span> ln f x <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>$</span> ln (<span style=color:#66d9ef>Identity</span> <span style=color:#f92672>.</span> f) x
</code></pre></div><p>And since <code>x</code> remains unchanged, and no operation is being performed upon it, we can go ahead and remove it from our definition</p><p>So our final definition of <code>over</code> using Identity stands as :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>over</span> ln f <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>$</span> ln (<span style=color:#66d9ef>Identity</span> <span style=color:#f92672>.</span> f)

<span style=color:#75715e>{-</span><span style=color:#75715e>
</span><span style=color:#75715e>    Arguments :
</span><span style=color:#75715e>    ln :: (a </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Identity a) </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; (s </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Identity s)
</span><span style=color:#75715e>    f  :: a </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; a
</span><span style=color:#75715e></span><span style=color:#75715e>-}</span>
</code></pre></div><h3 id=lens-as-a-getter>Lens as a getter<a href=#lens-as-a-getter class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Since we&rsquo;re implementing a getter we need to make use of <code>view</code> . The definition of <code>view</code> is</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>view</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens</span> s a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> a
</code></pre></div><p>which translates as , given a lens that focuses on <code>a</code> inside <code>s</code> and <code>s</code>, it returns <code>a</code></p><p>The type of our lens is</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>Lens</span> s a <span style=color:#f92672>::</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s
</code></pre></div><p>and by definition, view implements <code>s -> a</code> , which means, we need to find a way to convert <code>f s</code> to <code>a</code> .</p><p>We will be using Const to imlement the getter because it works for all (applicative) Functors and we wish to reuse the getter in a degenerate sense. Using <code>Const</code> is analogous to passing in const or id to functions that work, given arbitrary functions.</p><p>Lenses are defined in terms of arbitrary Functors, which is why we can make use of <code>Const</code> to derive a field accessor (and trivial Identity to derive a field updater).</p><h4 id=understanding-how-const-works><strong>Understanding how Const works</strong><a href=#understanding-how-const-works class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Const is defined as</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>newtype</span> <span style=color:#66d9ef>Const</span> a b <span style=color:#f92672>=</span> <span style=color:#66d9ef>Const</span> { getConst <span style=color:#f92672>::</span> a }

<span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Functor</span> (<span style=color:#66d9ef>Const</span> a) <span style=color:#66d9ef>where</span>
  fmap <span style=color:#66d9ef>_</span> (<span style=color:#66d9ef>Const</span> a) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Const</span> a
</code></pre></div><p>Const works as wrapper, which takes a value and hides it, pretends to be functor which contains something else, and ignores the function you are trying to <code>fmap</code> over Const.</p><p>For example let&rsquo;s hide string &ldquo;haskell&rdquo; inside a Const, and apply an bool function to it, using fmap.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>let</span> strBool <span style=color:#f92672>=</span> fmap (<span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>True</span>) (<span style=color:#66d9ef>Const</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>haskell</span><span style=color:#e6db74>&#34;</span>)
<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t strBool
<span style=color:#f92672>::</span> <span style=color:#66d9ef>Const</span> [<span style=color:#66d9ef>Char</span>] <span style=color:#66d9ef>Bool</span>
</code></pre></div><p>As you can see, the Const is now of type <code>Const [Char] Bool</code> .</p><p>Similarly, if we map over a function <code>Bool -> Int</code> we&rsquo;ll get type as <code>Const [Char] Int</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t fmap (<span style=color:#a6e22e>\</span><span style=color:#66d9ef>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span>) strBool
<span style=color:#f92672>::</span> <span style=color:#66d9ef>Const</span> [<span style=color:#66d9ef>Char</span>] <span style=color:#66d9ef>Int</span>
</code></pre></div><p><strong>Point to note</strong> : Const ignores the function we&rsquo;re doing <code>fmap</code> with, and takes on a new type, and ensures safety of our original <code>b</code> . We can etract it whenever desired, despite any numbers of <code>fmap</code> operations.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#f92672>&gt;</span> getConst strBool
<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>haskell</span><span style=color:#e6db74>&#34;</span>

<span style=color:#f92672>&gt;</span> getConst <span style=color:#f92672>$</span> fmap (<span style=color:#a6e22e>\</span><span style=color:#66d9ef>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span>) strBool
<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>haskell</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><h4 id=back-to-lens><strong>Back to lens</strong><a href=#back-to-lens class=hanchor arialabel=Anchor>&#8983;</a></h4><p>The final form of <code>view</code> looks like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>view</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> a
</code></pre></div><p>Since we can specialize <code>Lens' s a</code> type synonym to use (Const a) in place of <code>f</code> , we can represent our lens as <code>(a -> Const a a) -> (s -> Const a s)</code> .</p><p>Doing the same for <code>view</code> gives us</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>view</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> f a)

<span style=color:#75715e>-- `f` becomes `Const`</span>
<span style=color:#a6e22e>view</span> <span style=color:#f92672>::</span> ((a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Const</span> a a) <span style=color:#f92672>-&gt;</span> (s <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Const</span> a s)) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> a

<span style=color:#75715e>-- `f x` becomes `ln Const x`</span>
<span style=color:#a6e22e>view</span> ln x <span style=color:#f92672>=</span> <span style=color:#66d9ef>_</span> (ln <span style=color:#66d9ef>Const</span> x)

<span style=color:#75715e>-- using getConst to get back the original value of x</span>
<span style=color:#a6e22e>view</span> ln x <span style=color:#f92672>=</span> getConst (ln <span style=color:#66d9ef>Const</span> x)

<span style=color:#75715e>-- using point free style</span>
<span style=color:#a6e22e>view</span> ln x <span style=color:#f92672>=</span> getConst <span style=color:#f92672>$</span> ln <span style=color:#66d9ef>Const</span> x

<span style=color:#75715e>{-</span><span style=color:#75715e>
</span><span style=color:#75715e>    Arguments :
</span><span style=color:#75715e>    ln :: (a </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Const a a) </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; (s </span><span style=color:#75715e>-</span><span style=color:#75715e>&gt; Const a s)
</span><span style=color:#75715e>    x  :: s
</span><span style=color:#75715e></span><span style=color:#75715e>-}</span>
</code></pre></div><h3 id=defining-setter-using-const><strong>Defining setter using Const</strong><a href=#defining-setter-using-const class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Since we have already defined setters using <code>over</code> , the implementation with const is fairly trivial.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>set</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens</span> s a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> s

<span style=color:#75715e>-- set in terms for Functor f</span>
<span style=color:#a6e22e>set</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

<span style=color:#75715e>-- f becomes `Const`</span>
<span style=color:#75715e>-- using `over` to go through values in ln</span>
<span style=color:#a6e22e>set</span> ln x <span style=color:#f92672>=</span> over ln (const x)
</code></pre></div><h2 id=write-your-own-lens>Write your own lens<a href=#write-your-own-lens class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p>Lenses are nothing more than this: an easy way of modifying parts of some data.</p></li><li><p>Because it becomes so much easier to reason about certain concepts because of them, they see a wide use in situations where you have huge sets of data structures that have to interact with one another in various ways.</p></li><li><p>A simple lens can be defined as <code>type Lens' s a = Functor f => (a -> f a) -> s -> f s</code></p></li><li><p>To use lens as a simple modifier, use Identity in place of f.</p></li><li><p>You can also make use of <code>over</code> to define modifiers</p></li><li><p>To use lens as a getter, use <code>Const</code> as f - it would store the a value, save it from fmap and return as it is to you.</p></li><li><p><code>f</code> can be generalized to use any applicative functor.</p></li></ul><p>We can use the above knowledge to define our own lenses :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#75715e>{-</span><span style=color:#75715e># LANGUAGE Rank2Types #</span><span style=color:#75715e>-}</span>

<span style=color:#66d9ef>import</span> Control.Applicative
<span style=color:#66d9ef>import</span> Control.Monad.Identity

<span style=color:#75715e>-- The definition of Simple Lens:</span>
<span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> s a <span style=color:#f92672>=</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a) <span style=color:#f92672>-&gt;</span> s <span style=color:#f92672>-&gt;</span> f s

<span style=color:#75715e>-- Getter passes the Const functor to the lens:</span>
<span style=color:#a6e22e>view</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> a b <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> b
<span style=color:#a6e22e>view</span> l <span style=color:#f92672>=</span> getConst <span style=color:#f92672>.</span> (l <span style=color:#66d9ef>Const</span>)

<span style=color:#75715e>-- Updater passes the Identity functor to the lens:</span>
<span style=color:#a6e22e>over</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> a b <span style=color:#f92672>-&gt;</span> (b <span style=color:#f92672>-&gt;</span> b) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a)
<span style=color:#a6e22e>over</span> l f <span style=color:#f92672>=</span> runIdentity <span style=color:#f92672>.</span> l (<span style=color:#66d9ef>Identity</span> <span style=color:#f92672>.</span> f)

<span style=color:#a6e22e>set</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> a b <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a)
<span style=color:#a6e22e>set</span> l r <span style=color:#f92672>=</span> over l (const r)

<span style=color:#75715e>-- Example: -------------------------------------------</span>

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> { _x <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span>, _y <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span> }
    <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)

<span style=color:#a6e22e>xLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Point</span> <span style=color:#66d9ef>Double</span>
<span style=color:#a6e22e>xLens</span> f (<span style=color:#66d9ef>Point</span> x1 y1) <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Point</span> x y1) (f x1)

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Line</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Line</span> { _start <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>, _end <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>}
    <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)

<span style=color:#a6e22e>startLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Line</span> <span style=color:#66d9ef>Point</span>
<span style=color:#a6e22e>startLens</span> f (<span style=color:#66d9ef>Line</span> s e) <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Line</span> x e) (f s)

<span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
<span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
    <span style=color:#66d9ef>let</span> point <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> <span style=color:#ae81ff>2.0</span> <span style=color:#ae81ff>3.0</span>
    print <span style=color:#f92672>$</span> view _x point
    print <span style=color:#f92672>$</span> set _x <span style=color:#ae81ff>4.0</span> point

    <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> <span style=color:#66d9ef>Line</span> point point
    print <span style=color:#f92672>$</span> view _start point
    <span style=color:#66d9ef>let</span> newPoint <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> <span style=color:#ae81ff>6.0</span> <span style=color:#ae81ff>3.0</span>
    print <span style=color:#f92672>$</span> set _start newPoint line
</code></pre></div><h2 id=combine-lenses>Combine Lenses<a href=#combine-lenses class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Since lenses are just functions, we can compose them using using ordinary function composition.</p><p>Think of your function composition as of type</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs>(<span style=color:#f92672>.</span>) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> a b <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Lens&#39;</span> b c <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Lens&#39;</span> a c
</code></pre></div><p>Lens&rsquo; is just a type alias for higher order functions,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Lens&#39;</span> a b <span style=color:#f92672>=</span> forall f <span style=color:#f92672>.</span> <span style=color:#66d9ef>Functor</span> f <span style=color:#f92672>=&gt;</span> (b <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a)
</code></pre></div><p>So when you compose two higher order functions, you get back a new-higher order function</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs>(<span style=color:#f92672>.</span>) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Functor</span> f
    <span style=color:#f92672>=&gt;</span> ((b <span style=color:#f92672>-&gt;</span> f b) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a))
    <span style=color:#f92672>-&gt;</span> ((c <span style=color:#f92672>-&gt;</span> f c) <span style=color:#f92672>-&gt;</span> (b <span style=color:#f92672>-&gt;</span> f b))
    <span style=color:#f92672>-&gt;</span> ((c <span style=color:#f92672>-&gt;</span> f c) <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> f a))
</code></pre></div><p>Let&rsquo;s take our example of point and segment; and use <code>xLens</code> and <code>startLens</code> from the section above.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>startLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Line</span> <span style=color:#66d9ef>Point</span>
<span style=color:#a6e22e>xLens</span>     <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Point</span> <span style=color:#66d9ef>Double</span>
</code></pre></div><p>We can make a composition of these two lenses, by simply doing,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>startLens</span> <span style=color:#f92672>.</span> xLens <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Line</span> <span style=color:#66d9ef>Double</span>
</code></pre></div><p>This composite lens lets us get or set the x coordinate of the starting point of a line. We can use over and view on the composite Lens&rsquo; and they will behave exactly the way we expect:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>view</span> (point <span style=color:#f92672>.</span> x) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Line</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span>

<span style=color:#a6e22e>over</span> (point <span style=color:#f92672>.</span> x) <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Double</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Double</span>) <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Line</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Line</span>)
</code></pre></div><h2 id=lens-laws>Lens Laws<a href=#lens-laws class=hanchor arialabel=Anchor>&#8983;</a></h2><p>As per the documentation, there are three lens laws.</p><ol><li>You get back what you put in:</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>view</span> l (set l v s) <span style=color:#960050;background-color:#1e0010>≡</span> v
</code></pre></div><ol start=2><li>Putting back what you got doesn&rsquo;t change anything:</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>set</span> l (view l s) s <span style=color:#960050;background-color:#1e0010>≡</span> s
</code></pre></div><ol start=3><li>Setting twice is the same as setting once:</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>set</span> l v&#39; (set l v s) <span style=color:#960050;background-color:#1e0010>≡</span> set l v&#39; s
</code></pre></div><p><strong>Please follow these laws, because if you don&rsquo;t, the lens police will come and get you!</strong> 🚓</p><h2 id=exercise>Exercise<a href=#exercise class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Since we have defined <code>xLens</code> and <code>startLens</code> , try defining <code>yLens</code> and <code>endLens</code> on your own, and later combine them.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Point</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Point</span> { _x <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span>, _y <span style=color:#f92672>::</span> <span style=color:#66d9ef>Double</span> }
    <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)

<span style=color:#a6e22e>yLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Point</span> <span style=color:#66d9ef>Double</span>
<span style=color:#a6e22e>yLens</span> f (<span style=color:#66d9ef>Point</span> x1 y1) <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>y <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Point</span> x1 y) (f y1)

<span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Line</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Line</span> { _start <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>, _end <span style=color:#f92672>::</span> <span style=color:#66d9ef>Point</span>}
    <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)

<span style=color:#a6e22e>endLens</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Line</span> <span style=color:#66d9ef>Point</span>
<span style=color:#a6e22e>endLens</span> f (<span style=color:#66d9ef>Line</span> s e) <span style=color:#f92672>=</span> fmap (<span style=color:#a6e22e>\</span>y <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Line</span> s y) (f e)

<span style=color:#75715e>-- ghci</span>
<span style=color:#f92672>&gt;</span> endLens <span style=color:#f92672>.</span> yLens <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens&#39;</span> <span style=color:#66d9ef>Line</span> <span style=color:#66d9ef>Double</span>
</code></pre></div><p>Define a lens for changing the absolute value of a number using a lens :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hs data-lang=hs><span style=color:#a6e22e>_abs</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Real</span> a <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Lens&#39;</span> a a
<span style=color:#a6e22e>_abs</span> f n <span style=color:#f92672>=</span> update <span style=color:#f92672>&lt;$&gt;</span> f (abs n)
  <span style=color:#66d9ef>where</span>
    update x
      <span style=color:#f92672>|</span> x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>     <span style=color:#f92672>=</span> <span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>_abs: negative absolute value</span><span style=color:#e6db74>&#34;</span>
      <span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> signum n <span style=color:#f92672>*</span> x

<span style=color:#75715e>-- using _abs in ghci</span>

<span style=color:#75715e>-- add 10 to absolute value of n</span>
<span style=color:#f92672>&gt;</span> over _abs (<span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>)
<span style=color:#f92672>-</span><span style=color:#ae81ff>15</span>

<span style=color:#75715e>-- square the absolute value of n</span>
<span style=color:#f92672>&gt;</span> over _abs (<span style=color:#f92672>^</span> <span style=color:#ae81ff>10</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>)
<span style=color:#f92672>-</span><span style=color:#ae81ff>25</span>
</code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/ssh-port-forwarding/><span class=button__icon>←</span>
<span class=button__text>SSH Tunneling - Local, Remote & Dynamic</span></a></span>
<span class="button next"><a href=/posts/currying/><span class=button__text>What is Currying</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>