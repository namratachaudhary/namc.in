<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="/posts/lenses-part-1/"><link rel=canonical href=/posts/lenses-part-1/><link rel=alternate type=application/atom+xml href=/index.xml><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"Haskell Lens - Part 1","headline":"Haskell Lens - Part 1","description":"Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I\x26rsquo;ll learn something in the process, and you will too (hopefully!).\nBefore we begin, I\x26rsquo;d like to give a heads-up about few things, so you know what lies ahead.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2018","datePublished":"2018-03-26 13:00:58 \x2b0530 \x2b0530","dateModified":"2018-03-26 13:00:58 \x2b0530 \x2b0530","url":"\/posts\/lenses-part-1\/","keywords":["Haskell"]}</script><title>Haskell Lens - Part 1 -</title><meta property="og:title" content="Haskell Lens - Part 1 -"><meta property="og:type" content="article"><meta property="og:description" content="Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&rsquo;d like to give a heads-up about few things, so you know what lies ahead."><meta name=description content="Preface lens are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&rsquo;ll learn something in the process, and you will too (hopefully!).
Before we begin, I&rsquo;d like to give a heads-up about few things, so you know what lies ahead."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Haskell Lens - Part 1</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-03-26 13:00:58 +0530">26 Mar 2018</time></div><div class=col-xs-6></div></div></header><div class="post-content markdown-body"><h2 id=preface>Preface</h2><p><code>lens</code> are one of the most popular, yet confusing aspect of Haskell. To be fair, I could never really understand how they work. This series of posts is going to be my attempt to understand lens, the ideas and implementation details, and also the lens package. I hope I&rsquo;ll learn something in the process, and you will too (hopefully!).</p><p>Before we begin, I&rsquo;d like to give a heads-up about few things, so you know what lies ahead.</p><ol><li><p>I am assuming if you&rsquo;re here, you have a fair amount of idea about <code>Monoids</code>, <code>Monads</code>, <code>Functors</code>, <code>Applicatives</code>. If you&rsquo;re not very familiar with the concepts, here is a list of suggested reading.</p><ul><li><a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids>Applicative Monads</a></li><li><a href=https://namc.in/2018-01-12-applicative-functors>Applicative Functors</a></li><li><a href=http://learnyouahaskell.com/a-fistful-of-monads>LYAH</a></li><li><a href=http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>Functors, Applicatives, And Monads In Pictures</a></li></ul></li><li><p>In my opnion, you should probably get comfortable with those concepts before proceeding with lenses.</p></li><li><p>This is the most important part. I&rsquo;m learning as I write this post. So if you feel I&rsquo;m wrong about something, please do leave a note, and I&rsquo;d be more than happy to correct myself.</p></li></ol><hr><h2 id=introduction>Introduction</h2><p>The <code>lens</code> library allows us to query and update some value in deeply nested records. Well, that&rsquo;s the simplest problem it solves. So let&rsquo;s see some examples for better understanding.</p><p>The example I&rsquo;ve selected is close to a project I did.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- line.hs</span>

<span class=cm>{-</span><span class=cm># LANGUAGE TemplateHaskell #</span><span class=cm>-}</span>

<span class=kr>data</span> <span class=kt>Line</span> <span class=ow>=</span> <span class=kt>Line</span> <span class=p>{</span> <span class=n>_start</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>,</span> <span class=n>_end</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>

<span class=kr>data</span> <span class=kt>Point</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>::</span> <span class=kt>Double</span><span class=p>,</span> <span class=n>_y</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=p>}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>
</code></pre></div><p>Let&rsquo;s try to define a few getters and setters!</p><p>Keep in mind! We haven&rsquo;t <em>yet</em> started using Lenses, so we will do it the old school way!</p><p>Setter =></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- helper functions to make Point and Line</span>

<span class=nf>makePoint</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Point</span>
<span class=nf>makePoint</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=n>x</span> <span class=n>y</span>

<span class=nf>makeLine</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Line</span>
<span class=nf>makeLine</span> <span class=n>start</span> <span class=n>end</span> <span class=ow>=</span> <span class=kt>Line</span> <span class=p>(</span><span class=n>makePoint</span> <span class=n>start</span><span class=p>)</span> <span class=p>(</span><span class=n>makePoint</span> <span class=n>end</span><span class=p>)</span>
</code></pre></div><p>Now since data is immutable, you&rsquo;d actually be creating a new point/line with given parameters.</p><p>Getters =></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=kr>let</span> <span class=n>line</span> <span class=ow>=</span> <span class=n>makeLine</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>

<span class=c1>-- Record syntax gives functions for accessing the fields</span>
<span class=c1>-- following gives the _y coordinate of _end of line</span>

<span class=o>&gt;</span> <span class=n>_y</span> <span class=o>.</span> <span class=n>_end</span> <span class=o>$</span> <span class=n>line</span>
</code></pre></div><p>Now consider you want to change the <code>_x</code> position of <code>_start</code> point of the <code>line</code> we have defined above, you have to write this:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>line2</span> <span class=ow>=</span> <span class=n>line</span> <span class=p>{</span> <span class=n>_start</span> <span class=ow>=</span> <span class=p>(</span><span class=n>_start</span> <span class=n>line</span><span class=p>)</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>=</span> <span class=mi>4</span> <span class=p>}</span> <span class=p>}</span>
</code></pre></div><p>It works, but it looks clumsy. And it definitely gets tougher to pack/upack data as more fields are added to each data type! Or if your data becomes more deeply nested.</p><p>This is because you need to re-create all of the wrapping objects around the value that you are changing, because Haskell values are immutable.</p><h2 id=simple-lens>Simple Lens</h2><p>A lens, by definition, is a first class getter and setter.</p><p><strong>What do you mean by first-class?</strong></p><p>A function is called <code>first class</code> when you can manipulate them using ordinary functional programming ways. You can pass them around the same way as integers, sequences.</p><ul><li>Can be used without restrictions - put in containers, passed as input and returned as output from functions</li><li>Can be constructed without restrictions - locally, globally, in-exression</li></ul><p>More details can be read <a href=http://freecontent.manning.com/learning-haskell-first-class-functions/>here</a>. The above definition is more than enough.</p><p>Lenses package <code>get</code> and <code>set</code> functionality into a single value. So you can loosely say, that lens is a record with two fields <code>view</code> and <code>set</code> and can be defined as</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Lens</span>
  <span class=p>{</span> <span class=n>view</span> <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
  <span class=p>,</span> <span class=n>set</span> <span class=ow>::</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=p>}</span>
</code></pre></div><p>Well, that&rsquo;s not how a lens is actually implemented, but it is the intuition. The above definition helps us define our lenses .</p><p>Lens comes in very handy in situation where data is deeply nested. What Lens typically does is; it groups two things together corresponding to a data structure:</p><ol><li>The view of a value (like <code>_x</code> and <code>_end</code> given above).</li><li>A corresponding function.</li></ol><p>Lenses combine 1 & 2, and give us the ability to read the values in the data structure, create new data structures with the value changed.</p><p>Going back the example we started with;</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Point</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>::</span> <span class=kt>Double</span><span class=p>,</span> <span class=n>_y</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=p>}</span>

<span class=c1>-- The &#34;view&#34; of the point variable _x</span>

<span class=nf>viewX</span> <span class=ow>::</span> <span class=kt>Point</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
<span class=nf>viewX</span> <span class=n>p</span> <span class=ow>=</span> <span class=n>_x</span> <span class=n>p</span>

<span class=c1>-- The &#34;set&#34; or &#34;update&#34; of point variable _x</span>

<span class=nf>setX</span> <span class=ow>::</span> <span class=kt>Point</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Point</span>
<span class=nf>setX</span> <span class=n>p</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>p</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>=</span> <span class=n>x</span> <span class=p>}</span>

<span class=c1>-- Now the lens combines view and set; by definiton</span>

<span class=nf>xLens</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Point</span> <span class=ow>-&gt;</span> <span class=kt>Double</span><span class=p>,</span> <span class=kt>Point</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Point</span><span class=p>)</span>
<span class=nf>xLens</span> <span class=ow>=</span> <span class=p>(</span><span class=n>viewX</span><span class=p>,</span> <span class=n>setX</span><span class=p>)</span>
</code></pre></div><p>There you have it! You&rsquo;ve successfully defined your first <code>Lens</code> !</p><p>Now there any many, many ways of defining lenses.</p><p>We will go more into detail about the <code>:type</code> of lenses.</p><p>According to our definition above, we can abstract out the type of lens as</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=kr>data</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Lens&#39;</span>
                     <span class=p>{</span> <span class=n>view</span>   <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
                     <span class=p>,</span> <span class=n>over</span>   <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span><span class=p>}</span>
</code></pre></div><p>i.e.; it is the combination of a view, and a set for some type <code>s</code> which has a field of type <code>a</code> .</p><p>The <code>xLens</code> above would be of type <code>Lens' Point Double</code> .</p><p>But the problem with this approach of writing a getter and a setter into a data type is that it doesnt scale very well.</p><p>If we wanted to do something like - increment the value of some field by 1, first we will have to define a getter for that field, then apply <code>+ 1</code> to it and then define a setter to set the new value.</p><p>We can try to combine this entire process, by providing another function to <code>Lens'</code> : <code>over</code> .</p><p>You can think of <code>over</code> as similar to <code>set</code> , with slightly different defintion, i.e. <code>over</code> can be understood as combinator for setters. It works a lot like fmap, except that you pass a setter as it&rsquo;s first argument to specify which part of the data structure you want to focus on.</p><p>In fact, you could use this similarly to <code>set</code>.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- using over to move _x by +1</span>

<span class=nf>over</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span><span class=p>)</span>

<span class=kr>let</span> <span class=n>p1</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>_y</span> <span class=ow>=</span> <span class=mi>3</span> <span class=p>}</span>
<span class=nf>over</span> <span class=n>xLens</span> <span class=p>(</span><span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=n>p1</span>
</code></pre></div><p>Okay, let&rsquo;s look back at our definition of <code>xLens</code> ; and see if we can redefine the definition of our lens using over.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- xLens :: (Point -&gt; Double, Point -&gt; Double -&gt; Point)</span>
<span class=c1>-- using &#34;over&#34;</span>

<span class=nf>xLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Point</span> <span class=kt>Double</span>
<span class=nf>xLens</span> <span class=ow>=</span> <span class=kt>Lens&#39;</span> <span class=n>_x</span>
                <span class=p>(</span><span class=nf>\</span><span class=n>a</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>=</span> <span class=n>a</span> <span class=p>}</span><span class=p>)</span>           <span class=c1>-- getter</span>
                <span class=p>(</span><span class=nf>\</span><span class=n>f</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>=</span> <span class=n>f</span> <span class=p>(</span><span class=n>_x</span> <span class=n>s</span><span class=p>)</span> <span class=p>}</span><span class=p>)</span>    <span class=c1>-- over</span>
</code></pre></div><p>Good so far!</p><p>But the problem now is that for each lens, we will have to provide a <code>view</code>, a <code>set</code> and <code>over</code> even if we&rsquo;re just using one of them!</p><p>We can solve this by using <code>const</code> .</p><p>It has a type <code>s -> a -> s</code> which allows us to write <code>over :: (a -> a) -> (s -> s)</code> as <code>set :: s -> a -> s</code> by partially applying it. In other words, we can rewrite <code>set</code> as :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>set</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
<span class=nf>set</span> <span class=n>xLens</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=n>over</span> <span class=n>xLens</span> <span class=p>(</span><span class=n>const</span> <span class=n>s</span><span class=p>)</span> <span class=n>a</span>
</code></pre></div><p>So the final definition of our lens looks like this :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Lens&#39;</span>
                     <span class=p>{</span> <span class=n>view</span> <span class=ow>::</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span>
                     <span class=p>,</span> <span class=n>over</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=p>}</span>

<span class=nf>set</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span>
<span class=nf>set</span> <span class=n>xLens</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=n>over</span> <span class=n>xLens</span> <span class=p>(</span><span class=n>const</span> <span class=n>s</span><span class=p>)</span> <span class=n>a</span>
</code></pre></div><p>Okay, so recap time!</p><ul><li>We saw how to define lenses using <code>view</code>, <code>set</code> and <code>over</code></li><li>We saw how to define <code>view</code> to retrieve value and <code>set</code>/<code>over</code> to retrieve values.</li><li>We also saw how we can rewrite <code>set</code>.</li></ul><p>Going back to definition : lenses package both &ldquo;get&rdquo; and &ldquo;set&rdquo; functionality into a single value (the lens).</p><p>You could pretend that a lens is a record with two fields:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Lens&#39;</span>
    <span class=p>{</span> <span class=n>view</span> <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
    <span class=p>,</span> <span class=n>over</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span><span class=p>)</span>
    <span class=p>}</span>
</code></pre></div><p>This looks a little different from our initial defintion, and if you have followed the transition so far, you probably understand why.</p><h2 id=using-functors>Using functors</h2><p>So far, we have seen how <code>over</code> can be used to reach nested nodes of a data structure. But the functionality was more related to <code>insert</code> than <code>update</code> . What if the modifier function needs to perform modifications where there are some side effects?</p><p>E.g. : We might want to print the value to the console; which is an IO function.</p><p>Just like before, we could add another function, using IO data type :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- new definition of lens</span>

<span class=kr>data</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Lens&#39;</span>
                     <span class=p>{</span> <span class=n>view</span>   <span class=ow>::</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
                     <span class=p>,</span> <span class=n>over</span>   <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>
                     <span class=p>,</span> <span class=n>overIO</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>IO</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>IO</span> <span class=n>s</span> <span class=p>}</span>
</code></pre></div><p>Again, there are some issues with the above implementation</p><ul><li>The definition of lens has grown again, and we would like very much to avoid that</li><li>What if <code>over</code> is used in more settings than just <strong>IO</strong>? Would we define new functions for the same?</li></ul><p>At this point we would like to revisit the definition of <code>over</code> and try to generalize it. You must have noticed, to define <code>overIO</code> we added <code>IO</code> .</p><p>We can easily swap IO for a more generalised type -> <strong>Functor</strong> .</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>over</span> <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>
</code></pre></div><p>Now here is an interesting argument. <code>over</code> is typically a functor modified, ie. â€“ it does what the original functor does, but it also attaches a value to it. Similarly, we can pick what Functor we specialize <code>f</code> to , and depending on which Functor we pick, we get different defintions.</p><p>For example :</p><p><strong>(This is covered in more details in following sections)</strong></p><p>if you pick (f = Const t), you get a <code>view</code> like function</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Getter&#39;</span> <span class=n>a</span> <span class=n>s</span> <span class=n>a</span>  <span class=ow>=</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Const</span> <span class=n>a</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Const</span> <span class=n>a</span> <span class=n>s</span><span class=p>)</span>

<span class=c1>--  equivalent to: (a -&gt; a) -&gt; (s -&gt; a)</span>
</code></pre></div><p>if you pick (f = Identity) , you get an <code>over</code> like function</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Setter&#39;</span> <span class=n>s</span> <span class=n>a</span>   <span class=ow>=</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>s</span><span class=p>)</span>

<span class=c1>--  equivalent to: (a -&gt; a) -&gt; (s -&gt; s)</span>
</code></pre></div><p>Now since we can use functor to implement both; getters and setters; we can redefine our lens to following :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=c1>-- new definition</span>

<span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>
</code></pre></div><p>By making this type an alias, instead of newtype or data, you can define your own lenses without depending on the lens library. Any function which has the appropriate type signature is a lens.</p><h2 id=rankntype>RankNType</h2><p>Lens uses <a href=https://wiki.haskell.org/Rank-N_types>rank 2 types</a> ; i.e. <code>Lens'</code> type synonym is polymorphic and occurs in the signature in what is called &ldquo;negative position&rdquo;, that is, to the left of the <code>-></code> .</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=c1>-- This typechecks</span>
<span class=nf>checks</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=n>t</span><span class=p>)</span> <span class=n>s</span>
<span class=nf>checks</span> <span class=ow>=</span> <span class=n>_1</span>

<span class=c1>-- This fails with error &#34;Illegal polymorphic or qualified type: Lens&#39; s t&#34;</span>
<span class=nf>fails</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=n>t</span><span class=p>)</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Int</span>
<span class=nf>fails</span> <span class=ow>=</span> <span class=n>const</span> <span class=mi>5</span>
</code></pre></div><p>Here the <strong>lens&rsquo;</strong> is in negative position, and ranges only over <code>s -> Int</code>. It is the implementation of <code>fails</code>, and not the caller of <code>fails</code>, the one who chooses the type of <code>s</code>. The caller must supply an argument function that works for all <code>s</code>.</p><p>Therefore it is imperetive to use :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=cm>{-</span><span class=cm># LANGUAGE RankNTypes #</span><span class=cm>-}</span> <span class=c1>-- Rank2Types is a synonym for RankNTypes</span>
</code></pre></div><p>at the top of your file. Without it, it&rsquo;s illegal to even use a lens type synonym since they use a part of the language you must enable. And if you try to use lens without enabling <code>RankNTypes</code> it will throw <strong>Illegal polymorphic error</strong>.</p><h2 id=lens-type>Lens Type</h2><p>So, the actual type for lenses is:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Lens</span> <span class=n>s</span> <span class=n>t</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>t</span>

<span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>
</code></pre></div><ul><li><a href=https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens><code>Lens</code></a> : Lens family as described in <a href=http://comonad.com/reader/2012/mirrored-lenses/>mirrored lenses</a></li><li><a href=https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-><code>Lens'</code></a> : Simple Lens, used whenever the type variables don&rsquo;t change upon setting a value.</li></ul><p>We&rsquo;ve already seen the derivation of <code>Lens'</code> type, in the previous section.</p><h3 id=different-forms-of-lenses>Different forms of lenses</h3><p>Quick recap of a few things we covered so far (they will be handly in this section)</p><ul><li>Lens represent a getter and a setter into some data type.</li><li>Setter can be generalized to work with functions, by using <code>over</code></li><li>Generalized <code>over</code> to the <a href=https://github.com/ekmett/lens/wiki/History-of-Lenses>van Laarhoven lens</a> of <strong>Functor f => (a -> f a) -> s -> f s</strong> .</li><li>We saw how <code>Lens' s a</code> can behave like <code>over</code> , <code>set</code> and <code>view</code> .</li></ul><p>But what if you just need a simple modification, and no functors, or vice versa?</p><p>In this section, we are going to define different forms of lenses, prove it and understand why it works as intended. We will be using two Functor instances that come from the base library, namely <strong>Data.Functor.Identity</strong> and <strong>Control.Applicative.Const</strong>.</p><h3 id=lens-as-ordinary-setter>Lens as ordinary setter</h3><p>If you just want to set or modify the value, use <code>Identity</code>, which is precisely the functor to use when you don&rsquo;t actually need one, because you can put a value in, let it behave as a functor and then the value out.</p><p><code>Identity</code> functor is defined as :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>newtype</span> <span class=kt>Identity</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>{</span> <span class=n>runIdentity</span> <span class=ow>::</span> <span class=n>a</span> <span class=p>}</span>

<span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>Identity</span> <span class=kr>where</span>
  <span class=n>fmap</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Identity</span> <span class=n>a</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Identity</span> <span class=p>(</span><span class=n>f</span> <span class=n>a</span><span class=p>)</span>
</code></pre></div><p><code>Identity</code> is also the &ldquo;empty&rdquo; functor and applicative functor, which means, <code>Identity</code> composed with another functor or applicative functor is isomorphic to the original. <code>Lens'</code> is defined as a function polymorphic in a Functor, therefore we can represent the defintion of <code>Lens' s a</code> in terms of <code>Functor</code> in the definition of <code>over</code>:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=nf>over</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>

<span class=c1>-- can be rewritten as</span>
<span class=nf>over</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span><span class=p>)</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>
</code></pre></div><p>Specializing <code>f</code> to <code>Identity</code> :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>s</span>

<span class=c1>-- which is isomorphic to</span>
<span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>
</code></pre></div><p>so given an updating function on a, return an updating function on s.</p><p>As we have already established, the final form of <code>over</code> is</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>over</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>
</code></pre></div><p>i.e. : Given a lens with focus on <code>a</code> inside of <code>s</code> , and a function from <code>a</code> to <code>a</code> and <code>s</code> , you get back a modified <code>s</code> after applying the function <code>over</code> to the focus point of the lens.</p><p>Keep in mind that <code>Lens</code> is just a function, nothing more</p><p>Therefore, by substituting <code>Lens s a</code> by <code>Identity</code> functor we can define <code>over</code> as :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>over</span> <span class=ow>::</span> <span class=p>(</span><span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=n>s</span><span class=p>)</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>

<span class=c1>-- which helps us define</span>
<span class=nf>over</span> <span class=n>ln</span> <span class=n>f</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>runIdentity</span> <span class=p>(</span><span class=n>ln</span> <span class=p>(</span><span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kt>Identity</span> <span class=p>(</span><span class=n>f</span> <span class=n>y</span><span class=p>)</span><span class=p>)</span> <span class=n>x</span><span class=p>)</span>

<span class=cm>{-</span><span class=cm>
</span><span class=cm>    Arguments :
</span><span class=cm>    ln :: (a </span><span class=cm>-</span><span class=cm>&gt; Identity a) </span><span class=cm>-</span><span class=cm>&gt; (s </span><span class=cm>-</span><span class=cm>&gt; Identity s)
</span><span class=cm>    f  :: a </span><span class=cm>-</span><span class=cm>&gt; a
</span><span class=cm>    x  :: a
</span><span class=cm></span><span class=cm>-}</span>

<span class=c1>-- a more syntactically pleasing version to write he above expression</span>
<span class=c1>-- could be by making use of point free style</span>
<span class=nf>over</span> <span class=n>ln</span> <span class=n>f</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>runIdentity</span> <span class=o>$</span> <span class=n>ln</span> <span class=p>(</span><span class=kt>Identity</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span> <span class=n>x</span>
</code></pre></div><p>And since <code>x</code> remains unchanged, and no operation is being performed upon it, we can go ahead and remove it from our definition</p><p>So our final definition of <code>over</code> using Identity stands as :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>over</span> <span class=n>ln</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>runIdentity</span> <span class=o>$</span> <span class=n>ln</span> <span class=p>(</span><span class=kt>Identity</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>

<span class=cm>{-</span><span class=cm>
</span><span class=cm>    Arguments :
</span><span class=cm>    ln :: (a </span><span class=cm>-</span><span class=cm>&gt; Identity a) </span><span class=cm>-</span><span class=cm>&gt; (s </span><span class=cm>-</span><span class=cm>&gt; Identity s)
</span><span class=cm>    f  :: a </span><span class=cm>-</span><span class=cm>&gt; a
</span><span class=cm></span><span class=cm>-}</span>
</code></pre></div><h3 id=lens-as-a-getter>Lens as a getter</h3><p>Since we&rsquo;re implementing a getter we need to make use of <code>view</code> . The definition of <code>view</code> is</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>view</span> <span class=ow>::</span> <span class=kt>Lens</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</code></pre></div><p>which translates as , given a lens that focuses on <code>a</code> inside <code>s</code> and <code>s</code>, it returns <code>a</code></p><p>The type of our lens is</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kt>Lens</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>::</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>
</code></pre></div><p>and by definition, view implements <code>s -> a</code> , which means, we need to find a way to convert <code>f s</code> to <code>a</code> .</p><p>We will be using Const to imlement the getter because it works for all (applicative) Functors and we wish to reuse the getter in a degenerate sense. Using <code>Const</code> is analogous to passing in const or id to functions that work, given arbitrary functions.</p><p>Lenses are defined in terms of arbitrary Functors, which is why we can make use of <code>Const</code> to derive a field accessor (and trivial Identity to derive a field updater).</p><h4 id=understanding-how-const-works><strong>Understanding how Const works</strong></h4><p>Const is defined as</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>newtype</span> <span class=kt>Const</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=kt>Const</span> <span class=p>{</span> <span class=n>getConst</span> <span class=ow>::</span> <span class=n>a</span> <span class=p>}</span>

<span class=kr>instance</span> <span class=kt>Functor</span> <span class=p>(</span><span class=kt>Const</span> <span class=n>a</span><span class=p>)</span> <span class=kr>where</span>
  <span class=n>fmap</span> <span class=kr>_</span> <span class=p>(</span><span class=kt>Const</span> <span class=n>a</span><span class=p>)</span> <span class=ow>=</span> <span class=kt>Const</span> <span class=n>a</span>
</code></pre></div><p>Const works as wrapper, which takes a value and hides it, pretends to be functor which contains something else, and ignores the function you are trying to <code>fmap</code> over Const.</p><p>For example let&rsquo;s hide string &ldquo;haskell&rdquo; inside a Const, and apply an bool function to it, using fmap.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=kr>let</span> <span class=n>strBool</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=p>(</span><span class=o>&amp;&amp;</span> <span class=kt>True</span><span class=p>)</span> <span class=p>(</span><span class=kt>Const</span> <span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span><span class=p>)</span>
<span class=o>&gt;</span> <span class=kt>:</span><span class=n>t</span> <span class=n>strBool</span>
<span class=ow>::</span> <span class=kt>Const</span> <span class=p>[</span><span class=kt>Char</span><span class=p>]</span> <span class=kt>Bool</span>
</code></pre></div><p>As you can see, the Const is now of type <code>Const [Char] Bool</code> .</p><p>Similarly, if we map over a function <code>Bool -> Int</code> we&rsquo;ll get type as <code>Const [Char] Int</code></p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=kt>:</span><span class=n>t</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>1</span> <span class=ow>::</span> <span class=kt>Int</span><span class=p>)</span> <span class=n>strBool</span>
<span class=ow>::</span> <span class=kt>Const</span> <span class=p>[</span><span class=kt>Char</span><span class=p>]</span> <span class=kt>Int</span>
</code></pre></div><p><strong>Point to note</strong> : Const ignores the function we&rsquo;re doing <code>fmap</code> with, and takes on a new type, and ensures safety of our original <code>b</code> . We can etract it whenever desired, despite any numbers of <code>fmap</code> operations.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=o>&gt;</span> <span class=n>getConst</span> <span class=n>strBool</span>
<span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span>

<span class=o>&gt;</span> <span class=n>getConst</span> <span class=o>$</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=kr>_</span> <span class=ow>-&gt;</span> <span class=mi>1</span> <span class=ow>::</span> <span class=kt>Int</span><span class=p>)</span> <span class=n>strBool</span>
<span class=s>&#34;</span><span class=s>haskell</span><span class=s>&#34;</span>
</code></pre></div><h4 id=back-to-lens><strong>Back to lens</strong></h4><p>The final form of <code>view</code> looks like</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>view</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</code></pre></div><p>Since we can specialize <code>Lens' s a</code> type synonym to use (Const a) in place of <code>f</code> , we can represent our lens as <code>(a -> Const a a) -> (s -> Const a s)</code> .</p><p>Doing the same for <code>view</code> gives us</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>view</span> <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span>

<span class=c1>-- `f` becomes `Const`</span>
<span class=nf>view</span> <span class=ow>::</span> <span class=p>(</span><span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=kt>Const</span> <span class=n>a</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>s</span> <span class=ow>-&gt;</span> <span class=kt>Const</span> <span class=n>a</span> <span class=n>s</span><span class=p>)</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>a</span>

<span class=c1>-- `f x` becomes `ln Const x`</span>
<span class=nf>view</span> <span class=n>ln</span> <span class=n>x</span> <span class=ow>=</span> <span class=kr>_</span> <span class=p>(</span><span class=n>ln</span> <span class=kt>Const</span> <span class=n>x</span><span class=p>)</span>

<span class=c1>-- using getConst to get back the original value of x</span>
<span class=nf>view</span> <span class=n>ln</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>getConst</span> <span class=p>(</span><span class=n>ln</span> <span class=kt>Const</span> <span class=n>x</span><span class=p>)</span>

<span class=c1>-- using point free style</span>
<span class=nf>view</span> <span class=n>ln</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>getConst</span> <span class=o>$</span> <span class=n>ln</span> <span class=kt>Const</span> <span class=n>x</span>

<span class=cm>{-</span><span class=cm>
</span><span class=cm>    Arguments :
</span><span class=cm>    ln :: (a </span><span class=cm>-</span><span class=cm>&gt; Const a a) </span><span class=cm>-</span><span class=cm>&gt; (s </span><span class=cm>-</span><span class=cm>&gt; Const a s)
</span><span class=cm>    x  :: s
</span><span class=cm></span><span class=cm>-}</span>
</code></pre></div><h3 id=defining-setter-using-const><strong>Defining setter using Const</strong></h3><p>Since we have already defined setters using <code>over</code> , the implementation with const is fairly trivial.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>set</span> <span class=ow>::</span> <span class=kt>Lens</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>s</span>

<span class=c1>-- set in terms for Functor f</span>
<span class=nf>set</span> <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=c1>-- f becomes `Const`</span>
<span class=c1>-- using `over` to go through values in ln</span>
<span class=nf>set</span> <span class=n>ln</span> <span class=n>x</span> <span class=ow>=</span> <span class=n>over</span> <span class=n>ln</span> <span class=p>(</span><span class=n>const</span> <span class=n>x</span><span class=p>)</span>
</code></pre></div><h2 id=write-your-own-lens>Write your own lens</h2><ul><li><p>Lenses are nothing more than this: an easy way of modifying parts of some data.</p></li><li><p>Because it becomes so much easier to reason about certain concepts because of them, they see a wide use in situations where you have huge sets of data structures that have to interact with one another in various ways.</p></li><li><p>A simple lens can be defined as <code>type Lens' s a = Functor f => (a -> f a) -> s -> f s</code></p></li><li><p>To use lens as a simple modifier, use Identity in place of f.</p></li><li><p>You can also make use of <code>over</code> to define modifiers</p></li><li><p>To use lens as a getter, use <code>Const</code> as f - it would store the a value, save it from fmap and return as it is to you.</p></li><li><p><code>f</code> can be generalized to use any applicative functor.</p></li></ul><p>We can use the above knowledge to define our own lenses :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=cm>{-</span><span class=cm># LANGUAGE Rank2Types #</span><span class=cm>-}</span>

<span class=kr>import</span> <span class=nn>Control.Applicative</span>
<span class=kr>import</span> <span class=nn>Control.Monad.Identity</span>

<span class=c1>-- The definition of Simple Lens:</span>
<span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>s</span> <span class=n>a</span> <span class=ow>=</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>s</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>s</span>

<span class=c1>-- Getter passes the Const functor to the lens:</span>
<span class=nf>view</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>b</span>
<span class=nf>view</span> <span class=n>l</span> <span class=ow>=</span> <span class=n>getConst</span> <span class=o>.</span> <span class=p>(</span><span class=n>l</span> <span class=kt>Const</span><span class=p>)</span>

<span class=c1>-- Updater passes the Identity functor to the lens:</span>
<span class=nf>over</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>
<span class=nf>over</span> <span class=n>l</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>runIdentity</span> <span class=o>.</span> <span class=n>l</span> <span class=p>(</span><span class=kt>Identity</span> <span class=o>.</span> <span class=n>f</span><span class=p>)</span>

<span class=nf>set</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>
<span class=nf>set</span> <span class=n>l</span> <span class=n>r</span> <span class=ow>=</span> <span class=n>over</span> <span class=n>l</span> <span class=p>(</span><span class=n>const</span> <span class=n>r</span><span class=p>)</span>

<span class=c1>-- Example: -------------------------------------------</span>

<span class=kr>data</span> <span class=kt>Point</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>::</span> <span class=kt>Double</span><span class=p>,</span> <span class=n>_y</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=p>}</span>
    <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>

<span class=nf>xLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Point</span> <span class=kt>Double</span>
<span class=nf>xLens</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Point</span> <span class=n>x1</span> <span class=n>y1</span><span class=p>)</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=kt>Point</span> <span class=n>x</span> <span class=n>y1</span><span class=p>)</span> <span class=p>(</span><span class=n>f</span> <span class=n>x1</span><span class=p>)</span>

<span class=kr>data</span> <span class=kt>Line</span> <span class=ow>=</span> <span class=kt>Line</span> <span class=p>{</span> <span class=n>_start</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>,</span> <span class=n>_end</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>}</span>
    <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>

<span class=nf>startLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Line</span> <span class=kt>Point</span>
<span class=nf>startLens</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Line</span> <span class=n>s</span> <span class=n>e</span><span class=p>)</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=n>x</span> <span class=ow>-&gt;</span> <span class=kt>Line</span> <span class=n>x</span> <span class=n>e</span><span class=p>)</span> <span class=p>(</span><span class=n>f</span> <span class=n>s</span><span class=p>)</span>

<span class=nf>main</span> <span class=ow>::</span> <span class=kt>IO</span> <span class=nb>()</span>
<span class=nf>main</span> <span class=ow>=</span> <span class=kr>do</span>
    <span class=kr>let</span> <span class=n>point</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=mf>2.0</span> <span class=mf>3.0</span>
    <span class=n>print</span> <span class=o>$</span> <span class=n>view</span> <span class=n>_x</span> <span class=n>point</span>
    <span class=n>print</span> <span class=o>$</span> <span class=n>set</span> <span class=n>_x</span> <span class=mf>4.0</span> <span class=n>point</span>

    <span class=kr>let</span> <span class=n>line</span> <span class=ow>=</span> <span class=kt>Line</span> <span class=n>point</span> <span class=n>point</span>
    <span class=n>print</span> <span class=o>$</span> <span class=n>view</span> <span class=n>_start</span> <span class=n>point</span>
    <span class=kr>let</span> <span class=n>newPoint</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=mf>6.0</span> <span class=mf>3.0</span>
    <span class=n>print</span> <span class=o>$</span> <span class=n>set</span> <span class=n>_start</span> <span class=n>newPoint</span> <span class=n>line</span>
</code></pre></div><h2 id=combine-lenses>Combine Lenses</h2><p>Since lenses are just functions, we can compose them using using ordinary function composition.</p><p>Think of your function composition as of type</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=o>.</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=kt>Lens&#39;</span> <span class=n>b</span> <span class=n>c</span> <span class=ow>-&gt;</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>c</span>
</code></pre></div><p>Lens&rsquo; is just a type alias for higher order functions,</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>type</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=n>forall</span> <span class=n>f</span> <span class=o>.</span> <span class=kt>Functor</span> <span class=n>f</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span>
</code></pre></div><p>So when you compose two higher order functions, you get back a new-higher order function</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=p>(</span><span class=o>.</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>Functor</span> <span class=n>f</span>
    <span class=ow>=&gt;</span> <span class=p>(</span><span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span><span class=p>)</span>
    <span class=ow>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=n>c</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>b</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>b</span><span class=p>)</span><span class=p>)</span>
    <span class=ow>-&gt;</span> <span class=p>(</span><span class=p>(</span><span class=n>c</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>c</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>a</span> <span class=ow>-&gt;</span> <span class=n>f</span> <span class=n>a</span><span class=p>)</span><span class=p>)</span>
</code></pre></div><p>Let&rsquo;s take our example of point and segment; and use <code>xLens</code> and <code>startLens</code> from the section above.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>startLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Line</span> <span class=kt>Point</span>
<span class=nf>xLens</span>     <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Point</span> <span class=kt>Double</span>
</code></pre></div><p>We can make a composition of these two lenses, by simply doing,</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>startLens</span> <span class=o>.</span> <span class=n>xLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Line</span> <span class=kt>Double</span>
</code></pre></div><p>This composite lens lets us get or set the x coordinate of the starting point of a line. We can use over and view on the composite Lens&rsquo; and they will behave exactly the way we expect:</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>view</span> <span class=p>(</span><span class=n>point</span> <span class=o>.</span> <span class=n>x</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>Line</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>

<span class=nf>over</span> <span class=p>(</span><span class=n>point</span> <span class=o>.</span> <span class=n>x</span><span class=p>)</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Line</span> <span class=ow>-&gt;</span> <span class=kt>Line</span><span class=p>)</span>
</code></pre></div><h2 id=lens-laws>Lens Laws</h2><p>As per the documentation, there are three lens laws.</p><ol><li>You get back what you put in:</li></ol><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>view</span> <span class=n>l</span> <span class=p>(</span><span class=n>set</span> <span class=n>l</span> <span class=n>v</span> <span class=n>s</span><span class=p>)</span> <span class=err>â‰¡</span> <span class=n>v</span>
</code></pre></div><ol start=2><li>Putting back what you got doesn&rsquo;t change anything:</li></ol><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>set</span> <span class=n>l</span> <span class=p>(</span><span class=n>view</span> <span class=n>l</span> <span class=n>s</span><span class=p>)</span> <span class=n>s</span> <span class=err>â‰¡</span> <span class=n>s</span>
</code></pre></div><ol start=3><li>Setting twice is the same as setting once:</li></ol><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>set</span> <span class=n>l</span> <span class=n>v&#39;</span> <span class=p>(</span><span class=n>set</span> <span class=n>l</span> <span class=n>v</span> <span class=n>s</span><span class=p>)</span> <span class=err>â‰¡</span> <span class=n>set</span> <span class=n>l</span> <span class=n>v&#39;</span> <span class=n>s</span>
</code></pre></div><p><strong>Please follow these laws, because if you don&rsquo;t, the lens police will come and get you!</strong> ðŸš“</p><h2 id=exercise>Exercise</h2><p>Since we have defined <code>xLens</code> and <code>startLens</code> , try defining <code>yLens</code> and <code>endLens</code> on your own, and later combine them.</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=kr>data</span> <span class=kt>Point</span> <span class=ow>=</span> <span class=kt>Point</span> <span class=p>{</span> <span class=n>_x</span> <span class=ow>::</span> <span class=kt>Double</span><span class=p>,</span> <span class=n>_y</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=p>}</span>
    <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>

<span class=nf>yLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Point</span> <span class=kt>Double</span>
<span class=nf>yLens</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Point</span> <span class=n>x1</span> <span class=n>y1</span><span class=p>)</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kt>Point</span> <span class=n>x1</span> <span class=n>y</span><span class=p>)</span> <span class=p>(</span><span class=n>f</span> <span class=n>y1</span><span class=p>)</span>

<span class=kr>data</span> <span class=kt>Line</span> <span class=ow>=</span> <span class=kt>Line</span> <span class=p>{</span> <span class=n>_start</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>,</span> <span class=n>_end</span> <span class=ow>::</span> <span class=kt>Point</span><span class=p>}</span>
    <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>

<span class=nf>endLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Line</span> <span class=kt>Point</span>
<span class=nf>endLens</span> <span class=n>f</span> <span class=p>(</span><span class=kt>Line</span> <span class=n>s</span> <span class=n>e</span><span class=p>)</span> <span class=ow>=</span> <span class=n>fmap</span> <span class=p>(</span><span class=nf>\</span><span class=n>y</span> <span class=ow>-&gt;</span> <span class=kt>Line</span> <span class=n>s</span> <span class=n>y</span><span class=p>)</span> <span class=p>(</span><span class=n>f</span> <span class=n>e</span><span class=p>)</span>

<span class=c1>-- ghci</span>
<span class=o>&gt;</span> <span class=n>endLens</span> <span class=o>.</span> <span class=n>yLens</span> <span class=ow>::</span> <span class=kt>Lens&#39;</span> <span class=kt>Line</span> <span class=kt>Double</span>
</code></pre></div><p>Define a lens for changing the absolute value of a number using a lens :</p><div class=highlight><pre class=chroma><code class=language-hs data-lang=hs><span class=nf>_abs</span> <span class=ow>::</span> <span class=kt>Real</span> <span class=n>a</span> <span class=ow>=&gt;</span> <span class=kt>Lens&#39;</span> <span class=n>a</span> <span class=n>a</span>
<span class=nf>_abs</span> <span class=n>f</span> <span class=n>n</span> <span class=ow>=</span> <span class=n>update</span> <span class=o>&lt;$&gt;</span> <span class=n>f</span> <span class=p>(</span><span class=n>abs</span> <span class=n>n</span><span class=p>)</span>
  <span class=kr>where</span>
    <span class=n>update</span> <span class=n>x</span>
      <span class=o>|</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span>     <span class=ow>=</span> <span class=ne>error</span> <span class=s>&#34;</span><span class=s>_abs: negative absolute value</span><span class=s>&#34;</span>
      <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=n>signum</span> <span class=n>n</span> <span class=o>*</span> <span class=n>x</span>

<span class=c1>-- using _abs in ghci</span>

<span class=c1>-- add 10 to absolute value of n</span>
<span class=o>&gt;</span> <span class=n>over</span> <span class=n>_abs</span> <span class=p>(</span><span class=o>+</span> <span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=o>-</span><span class=mi>5</span><span class=p>)</span>
<span class=o>-</span><span class=mi>15</span>

<span class=c1>-- square the absolute value of n</span>
<span class=o>&gt;</span> <span class=n>over</span> <span class=n>_abs</span> <span class=p>(</span><span class=o>^</span> <span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=o>-</span><span class=mi>5</span><span class=p>)</span>
<span class=o>-</span><span class=mi>25</span>
</code></pre></div></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/currying/>What is Currying</a></li><li><a href=/posts/foldables-traversals/>Foldable and Traversable in Haskell</a></li><li><a href=/posts/applicative-functors/>Haskell's Applicative Functors</a></li></ul></div><div style=height:50px></div><div class=site-footer></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>