<!doctype html><html lang=en><head><title>lazy-seq - Lazy Sequences in Clojure :: __namc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Basic idea  Evaluation of an expression is delayed until the value is needed.
 There are two ways to achieve the above :
  use lambda functions at runtime
  use macros/special forms at compile time
  With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms."><meta name=keywords content="lazy-seq,lazy sequences,clojure"><meta name=robots content="noodp"><link rel=canonical href=/posts/lazy-seq/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:title content="lazy-seq - Lazy Sequences in Clojure :: __namc —"><meta name=twitter:description content="Basic idea  Evaluation of an expression is delayed until the value is needed.
 There are two ways to achieve the above :
  use lambda functions at runtime
  use macros/special forms at compile time
  With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms."><meta name=twitter:site content="/"><meta name=twitter:creator content><meta name=twitter:image content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="lazy-seq - Lazy Sequences in Clojure :: __namc —"><meta property="og:description" content="Basic idea  Evaluation of an expression is delayed until the value is needed.
 There are two ways to achieve the above :
  use lambda functions at runtime
  use macros/special forms at compile time
  With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms."><meta property="og:url" content="/posts/lazy-seq/"><meta property="og:site_name" content="lazy-seq - Lazy Sequences in Clojure"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-01-10 01:00:46 +0530 +0530"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>__namc</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=/posts/lazy-seq/>lazy-seq - Lazy Sequences in Clojure</a></h1><div class=post-meta><span class=post-date>January 10, 2018</span></div><span class=post-tags>#<a href=/tags/clojure/>Clojure</a>&nbsp;</span><div class=post-content><div><h3 id=basic-idea>Basic idea<a href=#basic-idea class=hanchor arialabel=Anchor>&#8983;</a></h3><blockquote><p>Evaluation of an expression is delayed until the value is needed.</p></blockquote><p>There are two ways to achieve the above :</p><ul><li><p>use lambda functions at runtime</p></li><li><p>use macros/special forms at compile time</p></li></ul><p>With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms.</p><p>Let’s take an example from the <a href=http://clojuredocs.org/clojure.core/lazy-seq>Clojure docs for lazy-seq</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq
 (lazy-cat [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>] (map + (rest fib-seq) fib-seq)))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
</code></pre></div><p><code>lazy-cat</code> is another macro to concatenate lazy sequences. We shall write the above expression to an alternate translation which uses <code>lazy-seq</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq (concat (<span style=color:#a6e22e>lazy-seq</span> [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) (<span style=color:#a6e22e>lazy-seq</span> (map + (rest fib-seq) fib-seq))))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
user&gt; (doall (take <span style=color:#ae81ff>2000</span> fib-seq))
</code></pre></div><p>This lazy-seq evaluates for very large indexes without giving an <code>OutOfMemoryException/StackOverFlowError</code>. (Might throw ArithmeticException for extremely large integer, though)</p><p>How this works internally :</p><ul><li><p><code>lazy-seq</code> executes the body once the first time it is accessed.</p></li><li><p>the result is cached and used whenever the function is called in future.</p></li></ul><p>Going back to the example;</p><p><code>[0 1]</code> is the base case for the problem. In Fibonacci’s sequence, the first two values are 0 and 1. The consecutive computation of each value requires summation of previous value and the value before that one. Hence, we need at least two values to start the process.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(map + (rest fib-seq) fib-seq) 
</code></pre></div><p>Here, rest will return the part of fib-seq without it’s head. map will combine two sequences using + and produce a next sequence. Let’s take the fibonacci sequence <code>fib-seq-temp</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq-temp [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>])
user&gt; (map + (rest fib-seq-temp) fib-seq-temp)
<span style=color:#75715e>;; =&gt; (1 2 3 5)</span>
</code></pre></div><p>The sequences fed to map are part of same basic sequence . The first sequence <code>(rest [seq])</code> is the base seq without the head. The second sequence is the base seq, including the first value.</p><p><strong>What is the base sequence here?</strong></p><p>According to fibonacci number’s definition, <code>A(n) = A(n-1) + A(n-2)</code> . We need to be able to access previously computed values in order to extend the sequence. So, we use the recursive reference to fib-seq to access our previous results. The base seq is typically <code>[0 1]</code> here to begin with.</p><p>Let’s follow the steps mentioned above and run through the process :</p><ul><li><p>Take the first element of <code>fib-seq</code> (base case [0 1] ) — 0</p></li><li><p>Take the second element of <code>fib-seq — 1</code></p></li><li><p>Take the third element of fib-seq — Stuck, aren’t we? </p></li></ul><p>Here, we use map to generate a sequence which is used as remaining values.</p><p>The sum of rest [0 1] which is 1, and first item of [0 1] , which is zero is 1 ; which is our result below.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (map + (rest [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) [<span style=color:#ae81ff>0</span>])
<span style=color:#75715e>;; =&gt; (1)</span>
</code></pre></div><p>Similarly, let’s repeat the process for generating fourth element.</p><p>We use map again for generating base seq. </p><p>Compute the sum of second item of rest [0 1], whose value is (1) as computed above; and second item of [0 1]</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (map + (rest [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) [<span style=color:#ae81ff>1</span>])
<span style=color:#75715e>;; =&gt; (2)</span>
</code></pre></div><p>Easy so far?</p><p>Now generate the fourth element. </p><p>Sum the third element of rest [0 1] (which we computed as 1) and fourth item generated from[0 1] (which was 2 ). And we get 3 .</p><p>This will keep building up to match the desired definition for series. To understand this better, let’s add a print statement to our original definition.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq
  (lazy-cat [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]
            (<span style=color:#a6e22e>map</span>
              (<span style=color:#66d9ef>fn </span>[a b]
                (println (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;%d + %d&#34;</span> a b)
                (+ a b))
            (rest fib-seq) fib-seq)))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
user&gt; (doall (take <span style=color:#ae81ff>10</span> fib-seq))
<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>3</span> + <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>5</span> + <span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>8</span> + <span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>13</span> + <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>21</span> + <span style=color:#ae81ff>13</span>
<span style=color:#75715e>;; =&gt; (0 1 1 2 3 5 8 13 21 34)</span>
</code></pre></div><p>—-</p><h3 id=working-with-different-data-types>Working with different data-types<a href=#working-with-different-data-types class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p><code>map</code> , <code>reduce</code> , <code>take</code> etc work in terms of <code>first</code> , <code>rest</code> and more .</p></li><li><p><code>first</code> (as well as others) ensure if the collection implements <code>ISeq</code> .</p></li><li><p>If yes, then these functions are implemented directly. Else, a seq view of the collection is created to implement first / more / rest .</p></li></ul><h3 id=lazy-seq-macro>lazy-seq macro<a href=#lazy-seq-macro class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p>The macro uses <code>thunk</code> to store the sequence-generating calculations.</p></li><li><p>When an element/chunk of sequence is requested, next thunk is called to retrieve the values.</p></li><li><p>The thunk creates next subroutine to represent the tail of the sequence (lose your head).</p></li><li><p>These thunks implement sequence interface, each thunk is called just once, and then cached. So the realized portion is just a sequence of values.</p></li></ul><h3 id=holding-onto-the-head>Holding onto the head<a href=#holding-onto-the-head class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Take these two methods to generate infinite lazy seqs of randoms.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defn </span>infinite[] (<span style=color:#a6e22e>lazy-seq</span> (cons (<span style=color:#a6e22e>rand</span>) (<span style=color:#a6e22e>infinite</span>))))
<span style=color:#75715e>;; =&gt; #&#39;user/infinite</span>
</code></pre></div><p>&ndash;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defn </span>infinite-1[] (<span style=color:#a6e22e>lazy-seq</span> (cons (<span style=color:#a6e22e>rand</span>) (<span style=color:#a6e22e>infinite-1</span>))))
<span style=color:#75715e>;; =&gt; #&#39;user/infinite-1</span>
user&gt; (<span style=color:#66d9ef>def </span>zyx (<span style=color:#a6e22e>infinite-1</span>))
</code></pre></div><p>If you try to run <code>(last (infinite))</code> ; it won’t crash, but will neither terminate. However, <code>(last zyx)</code> will crash quickly with an <code>OutOfMemoryError</code> .
This is because of “holding onto the head”.</p><p>In <code>(last (infinite))</code> , Clojure disposes the earlier members of sequence because it is able to determine that they are not of any use. Hence, memory is not lost. Whereas, in <code>(last zyx)</code> , the program is holding on to the definition , and hence, it is not able to clear the memory. This causes it to throw <code>OutOfMemoryError</code>.</p><h3 id=so-whats-the-point-of-lazy-seq>So what’s the point of lazy-seq ?<a href=#so-whats-the-point-of-lazy-seq class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p>lazy-seq is just one of many possible ways to create lazy sequences. And there are several other ways to do it in clojure.</p></li><li><p>If a sequence is not lazy, it often holds onto it’s head, which consumes a lot of heap space.</p></li><li><p>If it is lazy, it is computed, then discarded as it is not used for further computations.</p></li><li><p>This is particularly useful when you are dealing with huge sequences, and only using a small part of them for sequential computation.</p></li></ul><p>—-</p><p>More reading:</p><p><a href=https://purelyfunctional.tv/lesson/what-are-lazy-sequences/>Purely Functional - What are lazy sequences</a></p><p><a href=http://theatticlight.net/posts/Lazy-Sequences-in-Clojure/>Attic Light - Lazy Sequences in clojure</a></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/applicative-functors/><span class=button__icon>←</span>
<span class=button__text>Haskell's Applicative Functors</span></a></span>
<span class="button next"><a href=/posts/protocols/><span class=button__text>Structured Clojure: Protocols</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Blog by Namrata Chaudhary :: Powered by Hugo :: Theme made by panr</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>