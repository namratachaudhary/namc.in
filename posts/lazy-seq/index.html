<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="__namc"><meta property="og:url" content="/posts/lazy-seq/"><link rel=canonical href=/posts/lazy-seq/><link rel=alternate type=application/atom+xml href=/index.xml title="Namc's blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"\/"},"articleSection":"posts","name":"lazy-seq - Lazy Sequences in Clojure","headline":"lazy-seq - Lazy Sequences in Clojure","description":"lazy-seq - How? Why? And other heresies","inLanguage":"en-US","author":"__namc","creator":"__namc","publisher":"__namc","accountablePerson":"__namc","copyrightHolder":"__namc","copyrightYear":"2018","datePublished":"2018-01-10 01:00:46 \x2b0530 \x2b0530","dateModified":"2018-01-10 01:00:46 \x2b0530 \x2b0530","url":"\/posts\/lazy-seq\/","keywords":["Clojure"]}</script><title>lazy-seq - Lazy Sequences in Clojure - Namc's blog</title><meta property="og:title" content="lazy-seq - Lazy Sequences in Clojure - Namc's blog"><meta property="og:type" content="article"><meta property="og:description" content="lazy-seq - How? Why? And other heresies"><meta name=description content="lazy-seq - How? Why? And other heresies"><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Namc's blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class=post id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>__namc</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>lazy-seq - Lazy Sequences in Clojure</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-01-10 01:00:46 +0530">10 Jan 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://namc.in/>@__namc</a></div></div></div></header><div class="post-content markdown-body"><h3 id=basic-idea>Basic idea</h3><blockquote><p>Evaluation of an expression is delayed until the value is needed.</p></blockquote><p>There are two ways to achieve the above :</p><ul><li><p>use lambda functions at runtime</p></li><li><p>use macros/special forms at compile time</p></li></ul><p>With lazy eval techniques, it is possible to construct infinite data structures that are evaluated as consumed, using lambdas, closures and recursion. In clojure, they are generated using lazy-seq and cons forms.</p><p>Let’s take an example from the <a href=http://clojuredocs.org/clojure.core/lazy-seq>Clojure docs for lazy-seq</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq
 (lazy-cat [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>] (map + (rest fib-seq) fib-seq)))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
</code></pre></div><p><code>lazy-cat</code> is another macro to concatenate lazy sequences. We shall write the above expression to an alternate translation which uses <code>lazy-seq</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq (concat (<span style=color:#a6e22e>lazy-seq</span> [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) (<span style=color:#a6e22e>lazy-seq</span> (map + (rest fib-seq) fib-seq))))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
user&gt; (doall (take <span style=color:#ae81ff>2000</span> fib-seq))
</code></pre></div><p>This lazy-seq evaluates for very large indexes without giving an <code>OutOfMemoryException/StackOverFlowError</code>. (Might throw ArithmeticException for extremely large integer, though)</p><p>How this works internally :</p><ul><li><p><code>lazy-seq</code> executes the body once the first time it is accessed.</p></li><li><p>the result is cached and used whenever the function is called in future.</p></li></ul><p>Going back to the example;</p><p><code>[0 1]</code> is the base case for the problem. In Fibonacci’s sequence, the first two values are 0 and 1. The consecutive computation of each value requires summation of previous value and the value before that one. Hence, we need at least two values to start the process.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(map + (rest fib-seq) fib-seq) 
</code></pre></div><p>Here, rest will return the part of fib-seq without it’s head. map will combine two sequences using + and produce a next sequence. Let’s take the fibonacci sequence <code>fib-seq-temp</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq-temp [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>])
user&gt; (map + (rest fib-seq-temp) fib-seq-temp)
<span style=color:#75715e>;; =&gt; (1 2 3 5)</span>
</code></pre></div><p>The sequences fed to map are part of same basic sequence . The first sequence <code>(rest [seq])</code> is the base seq without the head. The second sequence is the base seq, including the first value.</p><p><strong>What is the base sequence here?</strong></p><p>According to fibonacci number’s definition, <code>A(n) = A(n-1) + A(n-2)</code> . We need to be able to access previously computed values in order to extend the sequence. So, we use the recursive reference to fib-seq to access our previous results. The base seq is typically <code>[0 1]</code> here to begin with.</p><p>Let’s follow the steps mentioned above and run through the process :</p><ul><li><p>Take the first element of <code>fib-seq</code> (base case [0 1] ) — 0</p></li><li><p>Take the second element of <code>fib-seq — 1</code></p></li><li><p>Take the third element of fib-seq — Stuck, aren’t we? </p></li></ul><p>Here, we use map to generate a sequence which is used as remaining values.</p><p>The sum of rest [0 1] which is 1, and first item of [0 1] , which is zero is 1 ; which is our result below.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (map + (rest [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) [<span style=color:#ae81ff>0</span>])
<span style=color:#75715e>;; =&gt; (1)</span>
</code></pre></div><p>Similarly, let’s repeat the process for generating fourth element.</p><p>We use map again for generating base seq. </p><p>Compute the sum of second item of rest [0 1], whose value is (1) as computed above; and second item of [0 1]</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (map + (rest [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]) [<span style=color:#ae81ff>1</span>])
<span style=color:#75715e>;; =&gt; (2)</span>
</code></pre></div><p>Easy so far?</p><p>Now generate the fourth element. </p><p>Sum the third element of rest [0 1] (which we computed as 1) and fourth item generated from[0 1] (which was 2 ). And we get 3 .</p><p>This will keep building up to match the desired definition for series. To understand this better, let’s add a print statement to our original definition.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>def </span>fib-seq
  (lazy-cat [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>]
            (<span style=color:#a6e22e>map</span>
              (<span style=color:#66d9ef>fn </span>[a b]
                (println (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;%d + %d&#34;</span> a b)
                (+ a b))
            (rest fib-seq) fib-seq)))
<span style=color:#75715e>;; =&gt; #&#39;user/fib-seq</span>
user&gt; (doall (take <span style=color:#ae81ff>10</span> fib-seq))
<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>3</span> + <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>5</span> + <span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>8</span> + <span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>13</span> + <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>21</span> + <span style=color:#ae81ff>13</span>
<span style=color:#75715e>;; =&gt; (0 1 1 2 3 5 8 13 21 34)</span>
</code></pre></div><p>—-</p><h3 id=working-with-different-data-types>Working with different data-types</h3><ul><li><p><code>map</code> , <code>reduce</code> , <code>take</code> etc work in terms of <code>first</code> , <code>rest</code> and more .</p></li><li><p><code>first</code> (as well as others) ensure if the collection implements <code>ISeq</code> .</p></li><li><p>If yes, then these functions are implemented directly. Else, a seq view of the collection is created to implement first / more / rest .</p></li></ul><h3 id=lazy-seq-macro>lazy-seq macro</h3><ul><li><p>The macro uses <code>thunk</code> to store the sequence-generating calculations.</p></li><li><p>When an element/chunk of sequence is requested, next thunk is called to retrieve the values.</p></li><li><p>The thunk creates next subroutine to represent the tail of the sequence (lose your head).</p></li><li><p>These thunks implement sequence interface, each thunk is called just once, and then cached. So the realized portion is just a sequence of values.</p></li></ul><h3 id=holding-onto-the-head>Holding onto the head</h3><p>Take these two methods to generate infinite lazy seqs of randoms.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defn </span>infinite[] (<span style=color:#a6e22e>lazy-seq</span> (cons (<span style=color:#a6e22e>rand</span>) (<span style=color:#a6e22e>infinite</span>))))
<span style=color:#75715e>;; =&gt; #&#39;user/infinite</span>
</code></pre></div><p>&ndash;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>user&gt; (<span style=color:#66d9ef>defn </span>infinite-1[] (<span style=color:#a6e22e>lazy-seq</span> (cons (<span style=color:#a6e22e>rand</span>) (<span style=color:#a6e22e>infinite-1</span>))))
<span style=color:#75715e>;; =&gt; #&#39;user/infinite-1</span>
user&gt; (<span style=color:#66d9ef>def </span>zyx (<span style=color:#a6e22e>infinite-1</span>))
</code></pre></div><p>If you try to run <code>(last (infinite))</code> ; it won’t crash, but will neither terminate. However, <code>(last zyx)</code> will crash quickly with an <code>OutOfMemoryError</code> .
This is because of “holding onto the head”.</p><p>In <code>(last (infinite))</code> , Clojure disposes the earlier members of sequence because it is able to determine that they are not of any use. Hence, memory is not lost. Whereas, in <code>(last zyx)</code> , the program is holding on to the definition , and hence, it is not able to clear the memory. This causes it to throw <code>OutOfMemoryError</code>.</p><h3 id=so-whats-the-point-of-lazy-seq>So what’s the point of lazy-seq ?</h3><ul><li><p>lazy-seq is just one of many possible ways to create lazy sequences. And there are several other ways to do it in clojure.</p></li><li><p>If a sequence is not lazy, it often holds onto it’s head, which consumes a lot of heap space.</p></li><li><p>If it is lazy, it is computed, then discarded as it is not used for further computations.</p></li><li><p>This is particularly useful when you are dealing with huge sequences, and only using a small part of them for sequential computation.</p></li></ul><p>—-</p><p>More reading:</p><p><a href=https://purelyfunctional.tv/lesson/what-are-lazy-sequences/>Purely Functional - What are lazy sequences</a></p><p><a href=http://theatticlight.net/posts/Lazy-Sequences-in-Clojure/>Attic Light - Lazy Sequences in clojure</a></p></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div class=releated-content><h3>Related Posts</h3><ul><li><a href=/posts/protocols/>Structured Clojure: Protocols</a></li><li><a href=/posts/atoms/>Clojure - Atoms</a></li></ul></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=/about target=_blank>About</a></div><div class=site-footer-item><a href=https://github.com/namratachaudhary target=_blank>Github</a></div><div class=site-footer-item><a href=https://www.linkedin.com/in/namrata-c-542b8a56/ target=_blank>LinkedIn</a></div><div class=site-footer-item><a href=/index.xml target=_blank>RSS</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>